<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Information Hub - Central Dashboard</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
    <link rel="preconnect" href="https://unpkg.com" crossorigin>
    <link rel="preconnect" href="https://esm.sh" crossorigin>
    <link rel="dns-prefetch" href="//cdnjs.cloudflare.com">
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <noscript><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet"></noscript>
    <link rel="icon" href="logo.svg" type="image/svg+xml">
    <link rel="preload" as="image" href="logo.svg">
    <link rel="alternate icon" href="favicon.ico">
    <link rel="apple-touch-icon" href="logo.png">
    <link rel="prefetch" href="section.html" as="document" crossorigin>
    <link rel="prefetch" href="section-script.js" as="script">
    <link rel="preload" href="config.js" as="script">
    <link rel="preload" href="database-supabase.js" as="script">
    <!-- <link rel="preload" href="hub-script.js" as="script"> -->
    
    <!-- Supabase config fallback for static hosting (e.g., GitHub Pages) -->
    <meta name="supabase-url" content="">
    <meta name="supabase-anon-key" content="">

    <!-- Load Supabase and config -->
    <script src="https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js" defer></script>
    <script src="config.js"></script>
    
    <script>
    // Initialize Supabase client immediately after config loads
    document.addEventListener('DOMContentLoaded', () => {
        console.log('Initializing Supabase client...');
        
        // Wait for Supabase library to load
        const initSupabase = async () => {
            // Fallback loader to ensure Supabase library is available even if the primary CDN fails
            async function ensureSupabaseLibrary() {
                if (window.supabase) return true;
                return await new Promise((resolve) => {
                    let resolved = false;
                    const done = (ok) => { if (!resolved) { resolved = true; resolve(!!ok); } };
                    
                    // Try alternate UMD CDN first (unpkg)
                    const existingAlt = document.querySelector('script[data-supabase-alt]');
                    if (!existingAlt) {
                        const s1 = document.createElement('script');
                        s1.src = 'https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js';
                        s1.async = true;
                        s1.setAttribute('data-supabase-alt', '1');
                        s1.onload = () => setTimeout(() => done(window.supabase), 0);
                        s1.onerror = () => {
                            // If UMD fails, try ESM import fallback
                            const m = document.createElement('script');
                            m.type = 'module';
                            m.textContent = "import{createClient}from 'https://esm.sh/@supabase/supabase-js@2'; window.supabase={createClient}; window.dispatchEvent(new Event('supabase-ready'));";
                            document.head.appendChild(m);
                            window.addEventListener('supabase-ready', () => done(true), { once: true });
                            // Hard timeout guard
                            setTimeout(() => done(window.supabase), 2500);
                        };
                        document.head.appendChild(s1);
                    }
                    
                    // If script tag already present, poll briefly
                    let tries = 0;
                    const poll = setInterval(() => {
                        tries++;
                        if (window.supabase || tries > 30) {
                            clearInterval(poll);
                            if (!resolved) done(window.supabase);
                        }
                    }, 100);
                    // Final safety timeout
                    setTimeout(() => { if (!resolved) done(window.supabase); }, 4000);
                });
            }

            let attempts = 0;
            while (!window.supabase && attempts < 50) {
                console.log('Waiting for Supabase library...', attempts + 1);
                await new Promise(resolve => setTimeout(resolve, 100));
                attempts++;
            }
            
            if (!window.supabase) {
                console.warn('Supabase library not available, attempting fallback loaders...');
                const ok = await ensureSupabaseLibrary();
                if (!ok) {
                    console.error('Supabase library failed to load after fallbacks');
                    return;
                }
            }
            
            // Build CONFIG from meta/local if config.js is not present
            if (!window.CONFIG) {
                try {
                    const metaUrl = document.querySelector('meta[name="supabase-url"]').content;
                    const metaKey = document.querySelector('meta[name="supabase-anon-key"]').content;
                    const url = window.SUPABASE_URL || metaUrl;
                    const key = window.SUPABASE_ANON_KEY || metaKey;
                    if (url && key) {
                        window.CONFIG = {
                            SUPABASE_URL: url,
                            SUPABASE_ANON_KEY: key,
                            APP_NAME: 'Information Hub',
                            VERSION: '1.0.0',
                            DB_RETRY_ATTEMPTS: 3,
                            DB_TIMEOUT_MS: 5000,
                            SESSION_TIMEOUT_MS: 24 * 60 * 60 * 1000,
                            MAX_LOGIN_ATTEMPTS: 5,
                            DEBUG_MODE: (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'),
                            ENABLE_LOGGING: true
                        };
                        console.log('CONFIG created from meta tags/local values');
                    } else {
                        console.error('CONFIG not available and no meta/local values found');
                        return;
                    }
                } catch (e) {
                    console.error('Failed to derive CONFIG from meta/local', e);
                    return;
                }
            }
            
            // Initialize Supabase client
            try {
                // Normalize globals to avoid mixed sources overriding
                window.SUPABASE_URL = window.CONFIG.SUPABASE_URL;
                window.SUPABASE_ANON_KEY = window.CONFIG.SUPABASE_ANON_KEY;
            } catch (_) {}
            window.supabaseClient = window.supabase.createClient(
                window.CONFIG.SUPABASE_URL, 
                window.CONFIG.SUPABASE_ANON_KEY,
                { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true } }
            );
            
            // Guard to prevent fallback re-initialization with placeholders
            window.SUPABASE_CLIENT_READY = true;
            try {
                // Lightweight auth-state debug (visible only in console)
                window.supabaseClient.auth.onAuthStateChange((event, session) => {
                    console.log('[AuthStateChange]', event, session && session.user ? session.user.email : null);
                });
            } catch (_) {}
            console.log('✅ Supabase client initialized successfully');
        };
        
        initSupabase();
    });
    </script>
    
    <script>
    // Backgrounds flag default: disabled; controlled only by Supabase site_settings
    try { window.globalBackgroundsEnabled = false; } catch (_) {}
    
    </script>

</head>
<body>
    <div id="loadingScreen" style="display: flex; justify-content: center; align-items: center; min-height: 100vh; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; position: fixed; top: 0; left: 0; width: 100%; z-index: 9999;">
        <div style="text-align: center;">
            <div style="border: 4px solid rgba(255, 255, 255, 0.3); border-radius: 50%; border-top: 4px solid white; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto;"></div>
            <h2>Loading Information Hub...</h2>
            <p>Please wait while we verify your access.</p>
        </div>
    </div>
    
    <div id="mainContent" style="display: none;">
    <div class="container">
        <header class="header">
            <div class="header-content">
                <div class="header-title">
                    <div class="logo-container">
                        <img src="logo.svg" alt="Company Logo" class="site-logo" loading="eager" decoding="async" fetchpriority="high">
                        <h1>Information Hub</h1>
                    </div>
                    <p>Central dashboard for accessing all functional areas and resources</p>
                </div>
                <div class="user-info">
                    <div class="user-details">
                        <span class="user-name" id="userName">Loading...</span>
                        <span class="user-role" id="userRole">Loading...</span>
                    </div>
                    <div class="user-actions">
                        <button class="btn btn-secondary" onclick="showUserProfile()" title="Profile">
                            <i class="fas fa-user"></i>
                        </button>
                        <button class="btn btn-secondary" onclick="logout()" title="Logout">
                            <i class="fas fa-sign-out-alt"></i>
                        </button>
                    </div>
                </div>
            </div>
            <div id="infoBar" class="info-bar" style="display:none;">
                <i class="fas fa-bullhorn" aria-hidden="true"></i>
                <div class="info-marquee">
                    <div id="infoBarTrack" class="info-marquee-track"></div>
                </div>
                <a href="#" id="infoBarViewAll" class="info-view-all" onclick="openAuditFromInfoBar(event)">View all</a>
            </div>
        </header>

        <div class="hub-grid"></div>

        <div class="quick-actions">
            <h3>Quick Actions</h3>
            <div class="action-buttons">
                <button class="action-btn" id="adminPanelBtn" onclick="openAdminPanel()" style="display:none;">
                    <i class="fas fa-cog"></i> User Management
                </button>
                
                <button class="action-btn" id="reshuffleBackgroundsBtn" onclick="reshuffleBackgrounds()" style="display:none;">
                    <i class="fas fa-images"></i> Reshuffle Backgrounds
                </button>
                <button class="action-btn" id="toggleGlobalBackgroundsBtn" onclick="toggleGlobalBackgrounds()">
                    <i class="fas fa-images"></i> Enable Backgrounds For Everyone
                </button>
            </div>
        </div>
        
        
        
    </div>

    <!-- User Profile Modal -->
    <div id="userProfileModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>User Profile</h2>
                <span class="close" onclick="closeModal('userProfileModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div class="profile-info">
                    <div class="profile-item">
                        <label>Name:</label>
                        <span id="profileName">-</span>
                    </div>
                    <div class="profile-item">
                        <label>Username:</label>
                        <span id="profileUsername">-</span>
                    </div>
                    <div class="profile-item">
                        <label>Role:</label>
                        <span id="profileRole">-</span>
                    </div>
                    <div class="profile-item">
                        <label>Email:</label>
                        <span id="profileEmail">-</span>
                    </div>
                    <div class="profile-item">
                        <label>Accessible Sections:</label>
                        <div id="profileSections" class="sections-list"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add User Modal -->
    <div id="addUserModal" class="modal" style="display:none;">
        <div class="modal-content" style="max-width:560px; width:95%;">
            <div class="modal-header">
                <h2>Add New User</h2>
                <span class="close" onclick="closeModal('addUserModal')">&times;</span>
            </div>
            <div class="modal-body">
                <form id="addUserForm" onsubmit="return submitAddUser(event)">
                    <div class="form-group">
                        <label>Username *</label>
                        <input type="text" id="newUsername" required placeholder="jdoe">
                    </div>
                    <div class="form-group">
                        <label>Password *</label>
                        <input type="password" id="newPassword" required placeholder="••••••••">
                    </div>
                    <div class="form-group">
                        <label>Full Name</label>
                        <input type="text" id="newName" placeholder="John Doe">
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="newEmail" placeholder="john.doe@example.com">
                    </div>
                    <div class="form-group">
                        <label>Role *</label>
                        <select id="newRole" required>
                            <option value="admin">Admin</option>
                            <option value="editor">Editor</option>
                            <option value="viewer" selected>Viewer</option>
                        </select>
                    </div>
                    <div class="form-actions" style="display:flex; gap:10px; justify-content:flex-end;">
                        <button type="button" class="btn btn-secondary" onclick="closeModal('addUserModal')">Cancel</button>
                        <button type="submit" class="btn btn-primary">Add User</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    <!-- Admin Panel Modal -->
    <div id="adminPanelModal" class="modal">
        <div class="modal-content admin-modal">
            <div class="modal-header">
                <h2>User Management Panel</h2>
                <span class="close" onclick="closeModal('adminPanelModal')">&times;</span>
            </div>
            <div class="modal-body">
                <div class="admin-tabs">
                    <div class="admin-tab active" onclick="switchAdminTab('users')">
                        <i class="fas fa-users"></i> Users
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('permissions')">
                        <i class="fas fa-key"></i> Permissions
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('audit')">
                        <i class="fas fa-history"></i> Audit Log
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('sections')">
                        <i class="fas fa-th-large"></i> Manage Sections
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('assignments')">
                        <i class="fas fa-user-check"></i> Section Assignments
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('export')">
                        <i class="fas fa-download"></i> Export Data
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('import')">
                        <i class="fas fa-upload"></i> Import Data
                    </div>
                    <div class="admin-tab" onclick="switchAdminTab('diagnostics')">
                        <i class="fas fa-stethoscope"></i> Diagnostics
                    </div>
                </div>

                <div class="admin-view-controls" style="display:flex;align-items:center;gap:12px;justify-content:flex-end;margin:8px 0 4px;">
                    <label style="display:flex;align-items:center;gap:8px;font-size:0.9rem;color:#444;">
                        <input type="checkbox" id="compactToggle" onchange="toggleCompactAdmin()"> Compact mode
                    </label>
                </div>
                
                <div class="admin-content">
                    <div id="users-tab" class="admin-tab-content active">
                        <div class="admin-section-header">
                            <h3>User Management</h3>
                            <button class="btn btn-primary" onclick="openAddUserModal()">
                                <i class="fas fa-plus"></i> Add User
                            </button>
                        </div>
                <div class="user-search-bar" style="margin:10px 0 12px; display:flex; gap:10px; align-items:center;">
                    <input id="userSearchInput" type="text" placeholder="Search users by name, username, email, or role" oninput="loadUsersList()" style="flex:1; padding:8px 10px; border:1px solid #e1e5e9; border-radius:6px;" />
                    <button class="btn btn-secondary" onclick="document.getElementById('userSearchInput').value=''; loadUsersList();">
                        <i class="fas fa-times"></i> Clear
                    </button>
                </div>
                        <div id="currentUserSummary" class="current-user-summary"></div>
                        <div id="usersList" class="users-list"></div>
                    </div>
                    
                    <div id="permissions-tab" class="admin-tab-content">
                        <div class="admin-section-header">
                            <h3>User Permission Management</h3>
                            <button class="btn btn-primary" onclick="refreshUserList()">
                                <i class="fas fa-sync"></i> Refresh
                            </button>
                        </div>
                        
                        <div class="permission-management">
                            <div class="user-selector">
                                <label for="permissionUserSelect">Select User to Manage:</label>
                                <select id="permissionUserSelect" onchange="loadUserPermissions()">
                                    <option value="">Choose a user...</option>
                                </select>
                            </div>
                            
                            <div id="userPermissionForm" style="display: none;">
                                <div class="permission-form">
                                    <h4 id="selectedUserName">User Permissions</h4>
                                    
                                    <div class="permission-section">
                                        <h5>Section Access & Edit Permissions</h5>
                                        <div class="bulk-permission-actions" style="display:flex;gap:8px;flex-wrap:wrap;margin:6px 0 10px;">
                                            <button class="btn btn-secondary" onclick="toggleAllAccess(true)"><i class="fas fa-check-square"></i> Access: All</button>
                                            <button class="btn btn-secondary" onclick="toggleAllAccess(false)"><i class="far fa-square"></i> Access: None</button>
                                            <span style="opacity:.4">|</span>
                                            <button class="btn btn-secondary" onclick="toggleAllEdit(true)"><i class="fas fa-pen-square"></i> Edit: All</button>
                                            <button class="btn btn-secondary" onclick="toggleAllEdit(false)"><i class="far fa-square"></i> Edit: None</button>
                                        </div>
                                        <div id="sectionCheckboxes" class="section-permissions"></div>
                                    </div>
                                    
                                    <div class="permission-actions">
                                        <button class="btn btn-primary" onclick="saveUserPermissions()">
                                            <i class="fas fa-save"></i> Save Permissions
                                        </button>
                                        <button class="btn btn-secondary" onclick="resetUserPermissions()">
                                            <i class="fas fa-undo"></i> Reset
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="audit-tab" class="admin-tab-content">
                        <div class="admin-section-header">
                            <h3>Audit Log</h3>
                            <button class="btn btn-primary" onclick="exportAuditLog()">
                                <i class="fas fa-download"></i> Export Audit Log
                            </button>
                        </div>
                        <div class="audit-filters">
                            <select id="auditUserFilter">
                                <option value="">All Users</option>
                            </select>
                            <select id="auditActionFilter">
                                <option value="">All Actions</option>
                                <option value="LOGIN">Login</option>
                                <option value="LOGOUT">Logout</option>
                                <option value="CREATE">Create</option>
                                <option value="UPDATE">Update</option>
                                <option value="DELETE">Delete</option>
                            </select>
                        </div>
                        <div id="auditLog" class="audit-log"></div>
                    </div>
                    
                    <div id="diagnostics-tab" class="admin-tab-content">
                        <div class="admin-section-header">
                            <h3>Admin Diagnostics</h3>
                            <button class="btn btn-primary" onclick="runAdminDiagnostics()">
                                <i class="fas fa-play"></i> Run Checks
                            </button>
                        </div>
                        <div id="diagnosticsOutput" class="diagnostics-output" style="padding:10px;border:1px solid #eee;border-radius:8px;background:#fafafa;min-height:60px;"></div>
                    </div>

                    <div id="sections-tab" class="admin-tab-content">
                        <div class="admin-section-header">
                            <h3>Section Management</h3>
                            <button class="btn btn-primary" onclick="addNewSection()">
                                <i class="fas fa-plus"></i> Add New Section
                            </button>
                        </div>
                        
                        <div class="sections-management">
                            <div class="sections-list" id="sectionsList">
                                <!-- Sections will be loaded here -->
                            </div>
                            
                            <div class="section-actions">
                                <button class="btn btn-secondary" onclick="saveSectionOrder()">
                                    <i class="fas fa-save"></i> Save Order
                                </button>
                                <button class="btn btn-warning" onclick="resetSections()">
                                    <i class="fas fa-undo"></i> Reset to Default
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <div id="assignments-tab" class="admin-tab-content">
                        <div class="admin-section-header">
                            <h3>User Section Assignments</h3>
                            <p>Assign specific sections to each user. Users will only see sections they are assigned to.</p>
                        </div>
                        <div class="assignment-search-bar" style="margin:10px 0 12px; display:flex; gap:10px; align-items:center;">
                            <input id="assignmentUserSearchInput" type="text" placeholder="Search users by name, username, email, or role" oninput="filterAssignmentsList()" style="flex:1; padding:8px 10px; border:1px solid #e1e5e9; border-radius:6px;" />
                            <button class="btn btn-secondary" onclick="document.getElementById('assignmentUserSearchInput').value=''; renderAssignmentsList();">
                                <i class="fas fa-times"></i> Clear
                            </button>
                        </div>
                        <div id="assignmentsStats" style="margin:6px 0 8px; color:#666; font-size:0.9rem;"></div>
                        <div id="assignmentsList" class="assignments-list"></div>
                    </div>
                    
                    <div id="export-tab" class="admin-tab-content">
                        <h3>Data Export</h3>
                        <div class="export-options">
                            <div class="export-card">
                                <h4>Complete Data Export</h4>
                                <p>Export all users, sections, resources, and activities</p>
                                <button class="btn btn-primary" onclick="exportAllData()">
                                    <i class="fas fa-download"></i> Export All Data
                                </button>
                                <div style="margin-top:10px;display:flex;gap:8px;flex-wrap:wrap;">
                                    <button class="btn btn-secondary" onclick="backupJson()">
                                        <i class="fas fa-database"></i> Backup JSON
                                    </button>
                                    <button class="btn btn-secondary" onclick="restoreJson()">
                                        <i class="fas fa-upload"></i> Restore JSON
                                    </button>
                                </div>
                            </div>
                            
                            <div class="export-card">
                                <h4>Section-Specific Export</h4>
                                <p>Export data for a specific section</p>
                                <select id="sectionExportSelect">
                                    <option value="">Select Section</option>
                                </select>
                                <button class="btn btn-secondary" onclick="exportSectionData()">
                                    <i class="fas fa-download"></i> Export Section
                                </button>
                            </div>
                            
                            <div class="export-card">
                                <h4>User-Specific Export</h4>
                                <p>Export data for a specific user</p>
                                <select id="userExportSelect">
                                    <option value="">Select User</option>
                                </select>
                                <button class="btn btn-secondary" onclick="exportUserData()">
                                    <i class="fas fa-download"></i> Export User Data
                                </button>
                            </div>
                        </div>
                    </div>

                    <div id="import-tab" class="admin-tab-content">
                        <h3>Data Import</h3>
                        <div class="export-options">
                            <div class="export-card">
                                <h4>Restore from JSON Backup</h4>
                                <p>Admin-only: restore users, sections, resources, and activities from a JSON backup.</p>
                                <button class="btn btn-secondary" onclick="restoreJson()">
                                    <i class="fas fa-file-import"></i> Restore JSON (Full)
                                </button>
                            </div>

                            <div class="export-card">
                                <h4>Import Sections Only (JSON)</h4>
                                <p>Admin-only: upsert sections and their config from a JSON file.</p>
                                <button class="btn" onclick="restoreSectionsOnly()">
                                    <i class="fas fa-layer-group"></i> Restore Sections Only
                                </button>
                            </div>

                            <div class="export-card">
                                <h4>Import Sections/Tabs/Resources (Excel)</h4>
                                <p>Download the template, fill it, then load and import below.</p>
                                <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:8px;">
                                    <button class="btn btn-secondary" onclick="downloadExcelTemplateForImport()">
                                        <i class="fas fa-file-download"></i> Download Excel Template
                                    </button>
                                    <input type="file" id="importXlsxInput" accept=".xlsx,.xls" />
                                    <button class="btn" onclick="loadExcelPreviewFromPanel()">
                                        <i class="fas fa-eye"></i> Load Excel
                                    </button>
                                </div>
                                <div id="excelImportSummary" style="display:none;color:#334155;background:#f6f9ff;border:1px solid #dbe7ff;padding:10px;border-radius:8px;margin: 8px 0;"></div>
                                <div id="excelCounts" style="display:none;grid-template-columns: repeat(3, 1fr); gap:8px;" class="counts">
                                    <div class="card">Sections: <strong id="excelSecCount">0</strong><div class="muted">Sheet: Sections</div></div>
                                    <div class="card">Tabs: <strong id="excelTabCount">0</strong><div class="muted">Sheet: Tabs</div></div>
                                    <div class="card">Resources: <strong id="excelResCount">0</strong><div class="muted">Sheet: Resources</div></div>
                                </div>
                                <div style="margin-top:10px;">
                                    <button id="excelImportBtn" class="btn btn-primary" onclick="importExcelPayloadFromPanel()" disabled>
                                        <i class="fas fa-file-import"></i> Import All
                                    </button>
                                </div>
                            </div>

                            <div class="export-card">
                                <h4>Import JSON (Sections/Tabs/Resources Only)</h4>
                                <p>Import just sections, tabs, and resources from a JSON file.</p>
                                <button class="btn" onclick="importJsonSectionsTabsResources()">
                                    <i class="fas fa-file-upload"></i> Import JSON
                                </button>
                                <div id="jsonImportSummary" style="display:none;color:#334155;background:#f6f9ff;border:1px solid #dbe7ff;padding:10px;border-radius:8px;margin: 8px 0;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    </div>
    <!-- Defer scripts to improve First Paint; XLSX will be loaded on demand -->
    <script src="database-supabase.js" defer></script>
    <script src="excel-export.js" defer></script>
    <script src="auth-script.js" defer></script>
    <script src="hub-script.js" defer></script>
    <script>
        console.log('navigateToSection function exists:', typeof window.navigateToSection);
        
        // Wait for all scripts to load before initializing
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('=== DOMContentLoaded started ===');
            
            // Wait for hub-script.js to be ready
            let retries = 0;
            const maxRetries = 100; // 10 seconds max wait
            
            while (retries < maxRetries && typeof window.informationHub === 'undefined') {
                console.log('Waiting for hub-script.js to load...', retries + 1);
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }
            
            if (typeof window.informationHub === 'undefined') {
                console.error('hub-script.js failed to load after waiting');
                // Graceful fallback: hide overlay and load sections directly via Supabase
                try {
                    const loadingScreen = document.getElementById('loadingScreen');
                    const mainContent = document.getElementById('mainContent');
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    if (mainContent) mainContent.style.display = 'block';
                } catch (_) {}
                try {
                    await loadSectionsFromSupabase();
                } catch (e) {
                    console.error('Fallback section load failed:', e);
                }
                return;
            }
            
            console.log('hub-script.js loaded successfully');
            
            // Show interface after scripts are ready
            const loadingScreen = document.getElementById('loadingScreen');
            const mainContent = document.getElementById('mainContent');
            
            if (loadingScreen) loadingScreen.style.display = 'none';
            try { const hip = document.getElementById('hubInitProgress'); if (hip) hip.remove(); } catch(_) {}
            if (mainContent) mainContent.style.display = 'block';
            
            // Show loading message while waiting for database
            const hubGrid = document.querySelector('.hub-grid');
            if (hubGrid) {
                hubGrid.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666; max-width: 500px; margin: 0 auto;">
                        <div style="border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                        <h3 style="margin-bottom: 10px; color: #333;">Loading Information Hub</h3>
                        <p style="margin-bottom: 20px; opacity: 0.8;">Connecting to Supabase and loading your sections...</p>
                        
                        <div style="background: #f8f9fa; border-radius: 15px; padding: 20px; margin: 20px 0; border: 1px solid #e9ecef;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <span style="font-size: 14px; font-weight: 500;">Progress</span>
                                <span id="hubProgressPercent" style="font-size: 14px; font-weight: 600; color: #3498db;">0%</span>
                            </div>
                            <div style="background: #e9ecef; border-radius: 10px; height: 8px; margin: 10px 0; overflow: hidden;">
                                <div id="hubProgressBar" style="background: linear-gradient(90deg, #3498db, #2ecc71); height: 100%; width: 0%; transition: width 0.5s ease; border-radius: 10px;"></div>
                            </div>
                            <p id="hubProgressText" style="font-size: 13px; margin: 10px 0 0 0; opacity: 0.8; min-height: 20px;">Initializing...</p>
                        </div>
                        
                        <div style="display: flex; justify-content: center; gap: 15px; margin-top: 20px; font-size: 12px; opacity: 0.6;">
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div id="connectionStatus" style="width: 8px; height: 8px; border-radius: 50%; background: #ffc107;"></div>
                                <span>Supabase</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div id="authStatus" style="width: 8px; height: 8px; border-radius: 50%; background: #6c757d;"></div>
                                <span>Auth</span>
                            </div>
                            <div style="display: flex; align-items: center; gap: 5px;">
                                <div id="dataStatus" style="width: 8px; height: 8px; border-radius: 50%; background: #6c757d;"></div>
                                <span>Data</span>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            // The hub-script.js will handle all authentication and data loading
            // No need to duplicate the logic here
            // Watchdog: if hub initialization stalls, load sections directly
            setTimeout(async () => {
                try {
                    const grid = document.querySelector('.hub-grid');
                    const stillLoading = grid && grid.innerHTML && grid.innerHTML.includes('Loading Information Hub');
                    if (stillLoading) {
                        console.warn('Hub init watchdog triggered, loading sections directly');
                        try {
                            const loadingScreen = document.getElementById('loadingScreen');
                            const mainContent = document.getElementById('mainContent');
                            if (loadingScreen) loadingScreen.style.display = 'none';
                            try { const hip = document.getElementById('hubInitProgress'); if (hip) hip.remove(); } catch(_) {}
                            if (mainContent) mainContent.style.display = 'block';
                        } catch (_) {}
                        await loadSectionsFromSupabase();
                    }
                } catch (e) { console.error('Watchdog error:', e); }
            }, 3000);
            
            // Add basic navigation function if not available
            if (typeof window.navigateToSection !== 'function') {
                window.navigateToSection = function(sectionId) {
                    console.log('Navigating to section:', sectionId);
                    // Simple navigation - will be overridden by hub-script.js when loaded
                    window.location.href = `section.html?section=${sectionId}`;
                };
            }
        });
        
        // Function to load sections from Supabase database
        async function loadSectionsFromSupabase() {
            console.time('loadSectionsFromSupabase');
            console.log('[Hub] Loading sections from Supabase...');
            updateHubProgress('Initializing Supabase connection...', 5);
            
            // Wait for Supabase client to be ready
            let retries = 0;
            const maxRetries = 50; // 5 seconds max wait
            
            while (retries < maxRetries && !window.supabaseClient) {
                updateHubProgress(`Connecting to Supabase... (${retries + 1}/${maxRetries})`, 10 + (retries * 1.5));
                await new Promise(resolve => setTimeout(resolve, 100));
                retries++;
            }
            
            if (!window.supabaseClient) {
                console.error('Supabase client not available after waiting');
                updateHubProgress('❌ Supabase connection failed', 100);
                setTimeout(() => showFallbackSections(), 2000);
                return;
            }
            
            try {
                updateHubProgress('✅ Supabase connected! Authenticating...', 25);
                
                // Check authentication status (prefer session restoration with retries)
                let user = null;
                try {
                    const { data: sess } = await window.supabaseClient.auth.getSession();
                    user = sess && sess.session && sess.session.user ? sess.session.user : null;
                } catch (_) {}
                if (!user) {
                    let tries = 0;
                    while (tries < 20 && !user) { // ~2s
                        await new Promise(r => setTimeout(r, 100));
                        try {
                            const { data: s2 } = await window.supabaseClient.auth.getSession();
                            user = s2 && s2.session && s2.session.user ? s2.session.user : null;
                        } catch (_) {}
                        tries++;
                    }
                }
                if (!user) {
                    console.error('[Hub] Authentication error: session missing');
                    updateHubProgress('❌ Authentication failed', 100);
                    setTimeout(() => showFallbackSections(), 2000);
                    return;
                }
                
                updateHubProgress(`✅ Authenticated as ${user.email}`, 35);
                
                // Test database connection (lightweight, correct count usage)
                updateHubProgress('Testing database connection...', 40);
                const { error: testError } = await window.supabaseClient
                    .from('sections')
                    .select('section_id', { head: true, count: 'exact' });
                
                if (testError) {
                    console.error('[Hub] Database connection test failed:', testError);
                    updateHubProgress('❌ Database connection failed', 100);
                    setTimeout(() => showFallbackSections(), 2000);
                    return;
                }
                
                updateHubProgress('✅ Database connection verified', 50);
                
                // Fetch sections from Supabase
                updateHubProgress('Fetching sections from database...', 60);
                const { data: sections, error } = await window.supabaseClient
                    .from('sections')
                    .select('section_id, name, icon, color, config')
                    .eq('config->>visible', 'true')
                    .order('name', { ascending: true });
                
                if (error) {
                    console.error('[Hub] Error fetching sections:', error);
                    updateHubProgress('❌ Error loading sections: ' + error.message, 100);
                    setTimeout(() => showFallbackSections(), 2000);
                    return;
                }
                
                console.log('[Hub] Sections loaded:', { count: (sections||[]).length, sample: (sections||[])[0] });
                updateHubProgress(`✅ Loaded ${sections ? sections.length : 0} sections`, 75);
                
                if (!sections || sections.length === 0) {
                    console.log('No sections found in database');
                    updateHubProgress('ℹ️ No sections found - showing empty state', 90);
                    setTimeout(() => {
                        showEmptyState();
                        updateHubProgress('✅ Ready!', 100);
                        try {
                            const loadingScreen = document.getElementById('loadingScreen');
                            const mainContent = document.getElementById('mainContent');
                            if (loadingScreen) loadingScreen.style.display = 'none';
                            if (mainContent) mainContent.style.display = 'block';
                        } catch (_) {}
                        console.timeEnd('loadSectionsFromSupabase');
                    }, 1000);
                    return;
                }
                
                console.log('[Hub] Loaded sections from Supabase (rendering)...');
                updateHubProgress('Rendering sections...', 85);
                
                // Simulate rendering progress
                setTimeout(() => {
                    updateHubProgress('Building section cards...', 90);
                    setTimeout(() => {
                        updateHubProgress('Finalizing layout...', 95);
                        setTimeout(() => {
                            renderSections(sections);
                            updateHubProgress('✅ Hub loaded successfully!', 100);
                            try {
                                const loadingScreen = document.getElementById('loadingScreen');
                                const mainContent = document.getElementById('mainContent');
                                if (loadingScreen) loadingScreen.style.display = 'none';
                                if (mainContent) mainContent.style.display = 'block';
                            } catch (_) {}
                            setTimeout(() => {
                                // Hide progress after success
                                const progressContainer = document.querySelector('.hub-grid > div');
                                try { if (progressContainer) progressContainer.remove(); } catch (_) {}
                                console.timeEnd('loadSectionsFromSupabase');
                            }, 1500);
                        }, 300);
                    }, 300);
                }, 500);
                
            } catch (error) {
                console.error('[Hub] Error loading sections:', error);
                updateHubProgress('❌ Unexpected error: ' + error.message, 100);
                setTimeout(() => showFallbackSections(), 2000);
            }
        }
        // Expose for console debugging on the hub page
        try { window.loadSectionsFromSupabase = loadSectionsFromSupabase; } catch (_) {}
        
        // Function to update hub progress
        function updateHubProgress(message, percentage) {
            const progressBar = document.getElementById('hubProgressBar');
            const progressText = document.getElementById('hubProgressText');
            const progressPercent = document.getElementById('hubProgressPercent');
            const connectionStatus = document.getElementById('connectionStatus');
            const authStatus = document.getElementById('authStatus');
            const dataStatus = document.getElementById('dataStatus');
            
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
            if (progressText) {
                progressText.textContent = message;
            }
            if (progressPercent) {
                progressPercent.textContent = percentage + '%';
            }
            
            // Update status indicators
            if (connectionStatus) {
                if (percentage >= 25) {
                    connectionStatus.style.background = '#28a745'; // Green
                } else if (percentage >= 10) {
                    connectionStatus.style.background = '#ffc107'; // Yellow
                } else {
                    connectionStatus.style.background = '#6c757d'; // Gray
                }
            }
            
            if (authStatus) {
                if (percentage >= 50) {
                    authStatus.style.background = '#28a745'; // Green
                } else if (percentage >= 35) {
                    authStatus.style.background = '#ffc107'; // Yellow
                } else {
                    authStatus.style.background = '#6c757d'; // Gray
                }
            }
            
            if (dataStatus) {
                if (percentage >= 75) {
                    dataStatus.style.background = '#28a745'; // Green
                } else if (percentage >= 60) {
                    dataStatus.style.background = '#ffc107'; // Yellow
                } else {
                    dataStatus.style.background = '#6c757d'; // Gray
                }
            }
        }
        
        // Function to render sections
        function renderSections(sections) {
            const hubGrid = document.querySelector('.hub-grid');
            if (!hubGrid) return;
            
            const sectionsHtml = sections.map(section => `
                <div class="hub-card" data-section-id="${section.section_id}" onclick="navigateToSection('${section.section_id}')">
                    <div class="card-icon" style="color: ${section.color || '#3498db'};">
                        <i class="${section.icon || 'fas fa-folder'}"></i>
                    </div>
                    <h3>${section.name || section.section_id}</h3>
                    <p>Access ${section.name || section.section_id} resources and tools</p>
                </div>
            `).join('');
            
            hubGrid.innerHTML = sectionsHtml;
        }
        
        // Function to show empty state when no sections exist
        function showEmptyState() {
            console.log('Showing empty state - no sections in database');
            const hubGrid = document.querySelector('.hub-grid');
            if (!hubGrid) return;
            
            hubGrid.innerHTML = `
                <div style="text-align: center; padding: 60px 20px; color: #666; grid-column: 1 / -1;">
                    <div style="font-size: 48px; margin-bottom: 20px; opacity: 0.5;">
                        <i class="fas fa-folder-open"></i>
                    </div>
                    <h3>No Sections Available</h3>
                    <p>There are no sections configured in the database yet.</p>
                    <p style="font-size: 14px; margin-top: 10px; opacity: 0.7;">
                        Contact an administrator to add sections to the Information Hub.
                    </p>
                </div>
            `;
        }
        
        // Function to show fallback sections if database fails
        function showFallbackSections() {
            console.log('[Hub] Database connection failed, showing empty state');
            try {
                const loadingScreen = document.getElementById('loadingScreen');
                const mainContent = document.getElementById('mainContent');
                if (loadingScreen) loadingScreen.style.display = 'none';
                if (mainContent) mainContent.style.display = 'block';
            } catch (_) {}
            showEmptyState();
        }

        // Hard failsafe: if still loading after 6s, show empty state and reveal UI
        setTimeout(() => {
            try {
                const grid = document.querySelector('.hub-grid');
                const loadingOverlay = document.getElementById('loadingScreen');
                const main = document.getElementById('mainContent');
                const stuck = grid && grid.innerHTML && grid.innerHTML.includes('Loading Information Hub');
                if (stuck) {
                    console.warn('Failsafe: showing empty state');
                    showEmptyState();
                    if (loadingOverlay) loadingOverlay.style.display = 'none';
                    if (main) main.style.display = 'block';
                }
            } catch (_) {}
        }, 6000);
            
            // Initialize basic functions
            try { if (typeof ensureHeaderVisible === 'function') ensureHeaderVisible(); } catch(_) {}
            try { if (typeof startHeaderObserver === 'function') startHeaderObserver(); } catch(_) {}
        
        
        
        
        // On bfcache restore or fast back/forward, ensure hub is visible and refresh counts quickly
        window.addEventListener('pageshow', () => {
            try {
                const loadingScreen = document.getElementById('loadingScreen');
                const mainContent = document.getElementById('mainContent');
                if (loadingScreen) loadingScreen.style.display = 'none';
                if (mainContent) mainContent.style.display = 'block';
                // Ensure hub cards reflect latest section config (tabs) on return
                try { if (typeof updateMainHubSections === 'function') updateMainHubSections(); } catch(_) {}
                if (typeof updateSectionStats === 'function') updateSectionStats();
            } catch (_) {}
        });

        // Show hub as soon as database is ready, then build sections
        document.addEventListener('hubdb-ready', () => {
            try {
                const loadingScreen = document.getElementById('loadingScreen');
                const mainContent = document.getElementById('mainContent');
                if (loadingScreen) loadingScreen.style.display = 'none';
                try { const hip = document.getElementById('hubInitProgress'); if (hip) hip.remove(); } catch(_) {}
                if (mainContent) mainContent.style.display = 'block';
                if (typeof updateMainHubSections === 'function') updateMainHubSections();
                // Show/hide admin-only global backgrounds button
                // Global button is always visible in quick actions
                try { updateBackgroundToggleButton(); } catch(_) {}
                // Realtime sync: rebuild hub cards and stats when sections/resources change in Supabase
                try {
                    if (window.supabaseClient && !window.__hubSectionsRt) {
                        window.__hubSectionsRt = window.supabaseClient
                            .channel('hub-sections')
                            .on('postgres_changes', { event: '*', schema: 'public', table: 'sections' }, () => {
                                try { if (typeof updateMainHubSections === 'function') updateMainHubSections(); } catch(_) {}
                            })
                            .on('postgres_changes', { event: '*', schema: 'public', table: 'resources' }, () => {
                                try { if (typeof updateSectionStats === 'function') updateSectionStats(); } catch(_) {}
                            })
                            .subscribe();
                        window.addEventListener('beforeunload', () => { try { window.supabaseClient.removeChannel(window.__hubSectionsRt); } catch(_) {} }, { once: true });
                    }
                } catch(_) {}
            } catch(_) {}
        }, { once: true });

        // Final window-load fallback to ensure UI becomes visible
        window.addEventListener('load', () => {
            try {
                setTimeout(async () => {
                    const loadingScreen = document.getElementById('loadingScreen');
                    const mainContent = document.getElementById('mainContent');
                    if (loadingScreen && getComputedStyle(loadingScreen).display !== 'none') {
                        loadingScreen.style.display = 'none';
                        if (mainContent) mainContent.style.display = 'block';
                        try { if (typeof window.loadSectionsFromSupabase === 'function') await window.loadSectionsFromSupabase(); } catch (_) {}
                    }
                }, 1000);
            } catch (_) {}
        });
        
        // Also update interface when page becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                console.log('Page became visible, updating user interface...');
                updateUserInterface(); 
                try { if (typeof rotateInfoBar === 'function') rotateInfoBar(); } catch(_) {}
                try { if (typeof ensureHeaderVisible === 'function') ensureHeaderVisible(); } catch(_) {}
                try { if (typeof startHeaderObserver === 'function') startHeaderObserver(); } catch(_) {}
                try { if (typeof updateSectionStats === 'function') updateSectionStats(); } catch(_) {}
            }
        });
        
        // Update interface when window gains focus
        window.addEventListener('focus', () => {
            console.log('Window gained focus, updating user interface...');
            updateUserInterface(); 
            try { if (typeof rotateInfoBar === 'function') rotateInfoBar(); } catch(_) {}
            try { if (typeof updateSectionStats === 'function') updateSectionStats(); } catch(_) {}
        });

        // Ensure global navigation helper exists
        if (typeof window.navigateToSection !== 'function') {
            window.navigateToSection = function(sectionId) {
                try {
                    if (!sectionId) return;
                    const url = `section.html?section=${encodeURIComponent(sectionId)}`;
                    window.location.href = url;
                } catch (_) {}
            };
        }

        // Robust click delegation for hub cards
        document.addEventListener('click', (ev) => {
            try {
                const target = ev.target || ev.srcElement;
                const card = target && target.closest ? target.closest('.hub-card') : null;
                if (!card) return;
                const sid = card.getAttribute('data-section-id');
                if (sid && typeof window.navigateToSection === 'function') {
                    ev.preventDefault();
                    window.navigateToSection(sid);
                }
            } catch (_) {}
        });

        // Live refresh when section data changes in other tabs (e.g., Box Links rename)
        window.addEventListener('storage', (e) => {
            try {
                if (!e) return;
                const k = String(e.key || '');
                if (k.startsWith('section_') || k === 'informationHub' || k === 'hubActivities') {
                    console.log('Storage change detected:', k, '→ refreshing stats');
                    updateUserInterface();
                    updateSectionStats();
                    try { rotateInfoBar(); } catch(_) {}
                }
                // Rebuild cards if per-section config changed to reflect label/name updates
                if (k.startsWith('section_config_')) {
                    console.log('Section config change detected:', k, '→ rebuilding hub cards');
                    updateMainHubSections();
                }
            } catch (_) {}
        });
        
        // Real-time section → hub sync
        try {
            if (typeof BroadcastChannel !== 'undefined') {
                const bc = new BroadcastChannel('hub-sync');
                bc.onmessage = (event) => {
                    try {
                        const msg = event && event.data ? event.data : {};
                        if (msg && msg.source === 'section') {
                            console.log('Hub received sync message:', msg);
                            // If section customized or returning from section view, rebuild cards to reflect new tabs
                            if (msg.type === 'SECTION_CUSTOMIZE' || msg.type === 'NAV_BACK') {
                                try { updateMainHubSections(); } catch(_) {}
                            } else {
                                updateSectionStats();
                            }
                            try { rotateInfoBar(); } catch(_) {}
                        }
                    } catch (_) {}
                };
            }
        } catch (_) {}

        // Backgrounds: toggle + detection helpers
        function backgroundsDisabled() {
            try {
                return window.globalBackgroundsEnabled !== true;
            } catch (_) {
                return true;
            }
        }

        function updateBackgroundToggleButton() {
            // Update admin global button label based on forced state
            try {
                const globalBtn = document.getElementById('toggleGlobalBackgroundsBtn');
                if (globalBtn) {
                    const enabled = window.globalBackgroundsEnabled === true;
                    globalBtn.innerHTML = enabled ? '<i class="fas fa-images"></i> Disable Global Backgrounds' : '<i class="fas fa-images"></i> Enable Backgrounds For Everyone';
                }
            } catch(_) {}
        }

        async function _waitForSupabaseReady(maxMs = 3000) {
            try {
                const step = 100; let waited = 0;
                while (waited < maxMs && !(window.supabaseClient && window.supabaseClient.from)) {
                    await new Promise(r => setTimeout(r, step));
                    waited += step;
                }
            } catch(_) {}
        }

        // Ensure the button label reflects the latest Supabase site_settings
        window.refreshBackgroundToggleUI = async function() {
            try {
                if (!(window.supabaseClient && window.supabaseClient.from)) return;
                const { data } = await window.supabaseClient
                    .from('site_settings')
                    .select('value')
                    .eq('key', 'backgrounds')
                    .single();
                let v = data && data.value;
                try { if (typeof v === 'string') v = JSON.parse(v); } catch(_) {}
                const force = !!(v && (v.forceEnabled === true || String(v.forceEnabled).toLowerCase() === 'true'));
                try { window.globalBackgroundsEnabled = force; } catch(_) {}
            } catch(_) {}
            updateBackgroundToggleButton();
        };

        window.toggleBackgrounds = async function() {
            try {
                await window.refreshGlobalBackgrounds();
                updateBackgroundToggleButton();
                try { await ensureBackgroundImagesLoaded(); } catch (_) {}
                try { await updateMainHubSections(); } catch (_) { try { updateMainHubSections(); } catch (_) {} }
            } catch (_) {}
        };

        // Global admin-controlled toggle: when enabled, override all users to show backgrounds
        window.toggleGlobalBackgrounds = async function() {
            try {
                if (!window.supabaseClient) { alert('Supabase not initialized'); return; }
                // Only admins can toggle globally; server-side check will also enforce
                const me = await (async()=>{ try { const { data: { user } } = await window.supabaseClient.auth.getUser(); if (!user) return null; const { data } = await window.supabaseClient.from('profiles').select('role, permissions').eq('id', user.id).single(); return data; } catch(_) { return null; } })();
                const role = String(me?.role||'').toLowerCase();
                const canManage = !!(me && me.permissions && me.permissions.canManageUsers);
                if (!(role === 'admin' || canManage)) { alert('Admin only'); return; }

                // Read current server setting and flip (robust to string JSON values)
                let current = null;
                try {
                    const { data } = await window.supabaseClient
                        .from('site_settings')
                        .select('value')
                        .eq('key', 'backgrounds')
                        .single();
                    current = data && data.value;
                } catch(_) { current = null; }
                try { if (typeof current === 'string') current = JSON.parse(current); } catch(_) {}
                const on = !!(current && (current.forceEnabled === true || String(current.forceEnabled).toLowerCase() === 'true'));
                const next = !on;
                const nextValue = Object.assign({}, current || {}, { forceEnabled: next });

                // Persist to site settings so all clients pick it up (Supabase only)
                const { error: upErr } = await window.supabaseClient
                    .from('site_settings')
                    .upsert({ key: 'backgrounds', value: nextValue }, { onConflict: 'key' });
                if (upErr) throw upErr;

                // Locally reflect immediately
                try { window.globalBackgroundsEnabled = !!next; } catch(_) {}
                updateBackgroundToggleButton();
                try { await ensureBackgroundImagesLoaded(); } catch(_) {}
                try { await updateMainHubSections(); } catch(_) {}
                try { informationHub && informationHub.showMessage && informationHub.showMessage(`Global backgrounds ${next ? 'enabled' : 'disabled'}`, 'success'); } catch(_) {}
            } catch (e) {
                console.error('Global background toggle failed:', e);
                try {
                    // Enhance error message for generic network issues
                    const base = (e && (e.message || e.error_description || e.hint)) ? (e.message || e.error_description || e.hint) : String(e || 'Unknown error');
                    const msg = /Failed to fetch/i.test(base) ? 'Network error. Check internet connectivity, Supabase URL/API key, and CORS settings.' : base;
                    alert('Failed to toggle global backgrounds: ' + msg);
                } catch(_) {
                    alert('Failed to toggle global backgrounds');
                }
            }
        };
        // Fetch and apply global backgrounds flags strictly from Supabase
        window.refreshGlobalBackgrounds = async function() {
            try {
                if (!(window.supabaseClient && window.supabaseClient.from)) return;
                let v = null;
                try {
                    const { data } = await window.supabaseClient
                        .from('site_settings')
                        .select('value')
                        .eq('key', 'backgrounds')
                        .single();
                    v = data && data.value;
                } catch (_) { v = null; }
                try { if (typeof v === 'string') v = JSON.parse(v); } catch(_) {}
                const prev = { enabled: !!window.globalBackgroundsEnabled, shuffleAt: window.__bgShuffleAt || '' };
                const nextEnabled = !!(v && (v.forceEnabled === true || String(v.forceEnabled).toLowerCase() === 'true'));
                const nextShuffle = v && v.shuffleAt ? String(v.shuffleAt) : '';
                const changed = (prev.enabled !== nextEnabled) || (prev.shuffleAt !== nextShuffle);
                try { window.globalBackgroundsEnabled = nextEnabled; } catch(_) {}
                window.__bgShuffleAt = nextShuffle;
                updateBackgroundToggleButton();
                if (changed) {
                    try { await ensureBackgroundImagesLoaded(); } catch(_) {}
                    try { await updateMainHubSections(); } catch(_) {}
                }
            } catch(_) {}
        };

        // On load, read global site setting and apply local override
        (async function(){
            // First pass: try immediately
            try { await window.refreshGlobalBackgrounds(); } catch(_) {}
            try { await window.refreshBackgroundToggleUI(); } catch(_) {}
            // Second pass: wait for Supabase and images to be ready, then re-apply
            try {
                await _waitForSupabaseReady(2500);
                await loadSectionBackgroundsFromDb();
                await ensureBackgroundImagesLoaded();
                await window.refreshGlobalBackgrounds();
                await updateMainHubSections();
                await window.refreshBackgroundToggleUI();
            } catch(_) {}
        })();

        // When the database becomes ready later, re-check and apply backgrounds flag
        try {
            document.addEventListener('hubdb-ready', () => {
                (async () => {
                    try { await _waitForSupabaseReady(1500); } catch(_) {}
                    try { await loadSectionBackgroundsFromDb(); } catch(_) {}
                    try { await ensureBackgroundImagesLoaded(); } catch(_) {}
                    try { await window.refreshGlobalBackgrounds(); } catch(_) {}
                    try { await updateMainHubSections(); } catch(_) {}
                    try { await window.refreshBackgroundToggleUI(); } catch(_) {}
                })();
            });
        } catch(_) {}

        // Keep the label in sync when tab regains focus
        try {
            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) {
                    (async () => {
                        try { await _waitForSupabaseReady(1000); } catch(_) {}
                        try { await loadSectionBackgroundsFromDb(); } catch(_) {}
                        try { await ensureBackgroundImagesLoaded(); } catch(_) {}
                        try { await window.refreshGlobalBackgrounds(); } catch(_) {}
                        try { await updateMainHubSections(); } catch(_) {}
                        try { await window.refreshBackgroundToggleUI(); } catch(_) {}
                    })();
                }
            });
        } catch(_) {}

        // Admin: Get current user from Supabase
        async function currentUser() {
            try {
                const { data: { user }, error } = await (window.supabaseClient ? window.supabaseClient.auth.getUser() : { data: { user: null }, error: new Error('No client') });
                if (error || !user) return null;
                
                // Get full user profile from database
            const { data: profile, error: profileError } = await (window.supabaseClient || supabase)
                    .from('profiles')
                    .select('*')
                    .eq('id', user.id)
                    .single();
                
                if (profileError) return null;
                return profile;
            } catch(_) { return null; }
        }
        async function isCurrentUserAdmin() {
            try {
                const u = await currentUser();
                if (!u) return false;
                const role = String(u.role || '').toLowerCase();
                return role === 'admin' || !!(u.permissions && u.permissions.canManageUsers);
            } catch(_) { return false; }
        }
        
        // Helper: normalize resource type to buckets we display on cards
        function normalizeResourceType(rawType) {
            try {
                const t = String(rawType || '').toLowerCase();
                if (!t) return null;
                if (t.includes('playbook')) return 'playbooks';
                if (t.includes('boxlink') || t.includes('box link') || t.includes('box')) return 'boxLinks';
                if (t.includes('dashboard')) return 'dashboards';
            } catch (_) {}
            return null;
        }

        // Canonicalization helpers to avoid double-counting across sources
        function canonicalizeUrlForKey(url) {
            try {
                let raw = String(url || '').trim();
                if (!raw) return '';
                if (!/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(raw)) raw = 'https://' + raw;
                const u = new URL(raw);
                // Lowercase host, remove trailing slash in pathname
                const host = (u.host || '').toLowerCase();
                const path = (u.pathname || '/').replace(/\/+$/, '');
                const norm = `${u.protocol}//${host}${path}${u.search || ''}`;
                return norm.toLowerCase();
            } catch (_) {
                return String(url || '').trim().toLowerCase();
            }
        }
        function canonicalKeyForResource(r) {
            const id = r && r.id !== undefined && r.id !== null ? String(r.id) : '';
            const title = String(r?.title || '').trim().toLowerCase();
            const urlKey = canonicalizeUrlForKey(r?.url);
            // Prefer pair key for robust de-duplication across regenerated IDs
            const pair = `t:${title}|u:${urlKey}`;
            return pair || (id ? `id:${id}` : '');
        }
        function seenAdd(seenById, seenByPair, r) {
            const id = r && r.id !== undefined && r.id !== null ? String(r.id) : '';
            const title = String(r?.title || '').trim().toLowerCase();
            const urlKey = canonicalizeUrlForKey(r?.url);
            const pair = `t:${title}|u:${urlKey}`;
            if (pair && seenByPair.has(pair)) return false;
            if (id && seenById.has(id)) return false;
            if (pair) seenByPair.add(pair);
            if (id) seenById.add(id);
            return true;
        }
        // Function to update section statistics using Supabase as the single source of truth
        async function updateSectionStats() {
            // Get sections and configs from Supabase (wrapper or direct), no local fallbacks
            let rows = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    rows = await hubDatabase.getAllSections();
                }
            } catch (e) {
                console.warn('Error loading sections from wrapper for stats:', e);
            }
            if ((!rows || rows.length === 0) && window.supabaseClient) {
                try {
                    const { data: direct } = await window.supabaseClient
                        .from('sections')
                        .select('*')
                        .order('name', { ascending: true });
                    rows = Array.isArray(direct) ? direct : [];
                } catch (e) {
                    console.warn('Error direct-loading sections for stats:', e);
                }
            }
            const visibleRows = (rows || []).filter(s => !(s && s.config && s.config.visible === false));
            const sections = visibleRows.map(s => s.section_id);

            // Build config map from the same Supabase-sourced rows
            const sectionConfigById = new Map();
            visibleRows.forEach(s => sectionConfigById.set(s.section_id, s.config || {}));

            const normUiType = (t) => String(t || '').toLowerCase().trim();
            const mapUiToDbType = (ui) => String(ui || '').toLowerCase().trim();

            function resolveDbTypeForUiType(sectionId, uiTid) {
                // Map UI tab ids to canonical DB types
                const t = normUiType(uiTid);
                if (t === 'boxlinks' || t === 'box-links' || t === 'box') return 'box-links';
                if (t === 'playbook' || t === 'playbooks') return 'playbooks';
                if (t === 'dashboard' || t === 'dashboards') return 'dashboards';
                return t;
            }

            function getSingleDbType(sectionId, uiTid) {
                return resolveDbTypeForUiType(sectionId, uiTid);
            }

            function updateCountDom(sectionId, tid, count) {
                try {
                    const candidates = [];
                    const rawId = String(tid || '').trim();
                    const uiId = (typeof normalizeTypeId === 'function') ? normalizeTypeId(rawId) : rawId;
                    const hyphenId = rawId.replace(/[A-Z]/g, (m) => '-' + m.toLowerCase());
                    candidates.push(`${sectionId}-${rawId}`);
                    if (uiId && uiId !== rawId) candidates.push(`${sectionId}-${uiId}`);
                    if (hyphenId && hyphenId !== rawId && hyphenId !== uiId) candidates.push(`${sectionId}-${hyphenId}`);
                    // Known aliases
                    if (uiId === 'boxLinks' || rawId === 'boxLinks' || rawId === 'box-links' || hyphenId === 'box-links') {
                        candidates.push(`${sectionId}-boxlinks`, `${sectionId}-box-links`, `${sectionId}-boxLinks`);
                    }
                    let el = null;
                    for (const id of candidates) { el = document.getElementById(id); if (el) break; }
                    if (el) el.textContent = count;
                } catch(_) {}
            }

            await Promise.all(sections.map(async (sectionId) => {
                // Determine types to mirror section detail tabs with defaults
                let typesList = [];
                try {
                    const cfg = sectionConfigById.get(sectionId);
                    if (cfg && Array.isArray(cfg.types) && cfg.types.length > 0) {
                        typesList = cfg.types.map(t => String((t && t.id !== undefined ? t.id : t) || '').trim()).filter(Boolean);
                    } else if (cfg && Array.isArray(cfg.tabs) && cfg.tabs.length > 0) {
                        typesList = cfg.tabs.map(x => String(x || '').trim()).filter(Boolean);
                    }
                } catch (_) {}
                // If still empty, derive from resources (distinct types for this section)
                if ((!typesList || typesList.length === 0) && window.supabaseClient) {
                    try {
                        const { data } = await window.supabaseClient
                            .from('resources')
                            .select('type')
                            .eq('section_id', sectionId);
                        const raw = Array.isArray(data) ? data.map(r => String(r.type||'').trim()).filter(Boolean) : [];
                        const mapped = raw.map(v => v.toLowerCase() === 'playbook' ? 'playbooks' : v.toLowerCase() === 'link' ? 'box-links' : v.toLowerCase() === 'dashboard' ? 'dashboards' : v);
                        typesList = Array.from(new Set(mapped));
                    } catch (_) {}
                }
                // No legacy defaults: if nothing is configured and no resources exist, show nothing
                if (!typesList || typesList.length === 0) {
                    typesList = [];
                }
                const normalizedTypes = Array.from(new Set(typesList.map(normUiType))).filter(Boolean);

                // Query Supabase counts per type and update DOM using robust candidates
                await Promise.all(normalizedTypes.map(async (tid) => {
                    if (!window.supabaseClient) { updateCountDom(sectionId, tid, 0); return; }
                    const dbType = getSingleDbType(sectionId, tid);
                    if (!dbType) { updateCountDom(sectionId, tid, 0); return; }
                    try {
                        const { count, error } = await window.supabaseClient
                            .from('resources')
                            .select('*', { count: 'exact', head: true })
                            .eq('section_id', sectionId)
                            .eq('type', dbType);
                        if (error) throw error;
                        updateCountDom(sectionId, tid, count || 0);
                    } catch (_) {
                        updateCountDom(sectionId, tid, 0);
                    }
                }));
            }));
        }



        
        
        // Centralized content activity logger
        window.recordContentActivity = async function({ action, section, type, title }) {
            try {
                // Get current user from Supabase
                const { data: { user }, error } = await (window.supabaseClient ? window.supabaseClient.auth.getUser() : { data: { user: null }, error: new Error('No client') });
                const username = user?.user_metadata?.username || user?.email || 'Unknown';
                
                const entry = {
                    username,
                    action: action || 'updated',
                    section: section || null,
                    type: type || 'resource',
                    title: title || '',
                    timestamp: new Date().toISOString()
                };
                
                // Save to database
                if (window.hubDatabase && window.hubDatabaseReady) {
                    await hubDatabase.addActivity(entry);
                }
                
                try { if (typeof rotateInfoBar === 'function') rotateInfoBar(); } catch(_) {}
            } catch(_) {}
        };
        // Filter: include only content updates (playbooks/boxlinks/dashboards)
        function isContentActivity(a) {
            try {
                const meta = (a && a.metadata) ? a.metadata : {};
                const typeFromMeta = String(meta.type || meta.category || '').toLowerCase();
                const t = String(a.type || a.resourceType || a.category || typeFromMeta || '').toLowerCase();
                const title = String(a.title || a.resource || a.description || '').toLowerCase();
                const action = String(a.action || '').toLowerCase();
                // Exclude auth/system and non-CRUD noise (open/close/view/review/like, nav)
                const disallowed = [
                    'login','logout','session','auth','permission','role','user login','user logout',
                    'open','opened','close','closed','view','viewed','visit','visited',
                    'nav','navigate','navigation','review','for review','like','liked','favorite','favourite','star','starred',
                    // Explicitly exclude admin tab switches/actions from the marquee
                    'switch_admin_tab','switch admin tab','switch','open_admin_panel','close_admin_panel','admin panel'
                ];
                if (disallowed.some(k => t.includes(k) || action.includes(k) || title.includes(k))) return false;
                // Include any content-oriented entities and CRUD-ish actions
                const contentTypes = ['playbooks','playbook','boxlinks','boxlink','dashboards','dashboard','section','sections','tab','tabs','resource','resources'];
                const contentVerbs = ['create','created','update','updated','delete','deleted','add','added','remove','removed','rename','renamed','reorder','reordered'];
                if (contentTypes.some(k => t.includes(k) || title.includes(k))) return true;
                if (contentVerbs.some(v => action.includes(v))) return true;
            } catch(_) {}
            return false;
        }
        // Info bar marquee: build scrolling track from latest activities
        window.rotateInfoBar = async function() {
            try {
                const infoBar = document.getElementById('infoBar');
                const track = document.getElementById('infoBarTrack');
                if (!infoBar || !track) return;
                // Ensure header logo/title visible as fail-safe
                try {
                    const logo = document.querySelector('.site-logo');
                    if (logo) logo.style.display = '';
                    const h1 = document.querySelector('.header-title h1');
                    if (h1 && !h1.textContent.trim()) h1.textContent = 'Information Hub';
                } catch(_) {}
                // Get activities from Supabase database
                let activities = [];
                try {
                    if (window.hubDatabase && window.hubDatabaseReady) {
                        activities = await hubDatabase.getActivities();
                    }
                } catch (_) {}
                // Filter to last 7 days
                const now = Date.now();
                const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
                activities = (activities || []).filter(a => {
                    const t = new Date(a.timestamp).getTime();
                    return Number.isFinite(t) && (now - t) <= sevenDaysMs && (now - t) >= 0;
                });
                // Keep only content activities
                activities = activities.filter(isContentActivity);
                // Sort by timestamp desc
                activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                const latest = activities.slice(0, 8);
                // Resolve section display names
                let sectionNames = {};
                try { sectionNames = getSectionDisplayNames ? getSectionDisplayNames() : {}; } catch(_) {}
                const prettyName = (key) => {
                    if (!key) return 'General';
                    if (sectionNames && sectionNames[key]) return sectionNames[key];
                    const s = String(key).replace(/-/g, ' ');
                    return s.charAt(0).toUpperCase() + s.slice(1);
                };
                // Escape helper for safe HTML
                const safe = (t) => { const d = document.createElement('div'); d.textContent = t || ''; return d.innerHTML; };
                // Augment section names from DB and build per-section tab name maps
                let tabNameBySection = {};
                try {
                    if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getAllSections === 'function') {
                        const secs = await hubDatabase.getAllSections();
                        (secs || []).forEach(s => {
                            try {
                                const sid = s.section_id || s.sectionId || s.id;
                                const nm = s.name || sid;
                                if (sid && nm && (!sectionNames[sid] || sectionNames[sid] === prettyName(sid))) {
                                    sectionNames[sid] = nm;
                                }
                                const cfg = s && typeof s.config === 'object' ? s.config : {};
                                const map = tabNameBySection[sid] || (tabNameBySection[sid] = {});
                                if (Array.isArray(cfg.types)) {
                                    cfg.types.forEach(t => {
                                        const tid = String((t && t.id !== undefined) ? t.id : t);
                                        const tname = String((t && t.name) || tid);
                                        if (tid) map[tid] = tname;
                                    });
                                } else if (Array.isArray(cfg.tabs)) {
                                    const names = Array.isArray(cfg.tab_names) ? cfg.tab_names : [];
                                    cfg.tabs.forEach((tid, i) => {
                                        const k = String(tid || '');
                                        if (k) map[k] = String(names[i] || k);
                                    });
                                }
                            } catch(_) {}
                        });
                    }
                } catch(_) {}
                // Prefetch resource titles for latest items
                const resourceNameById = {};
                try {
                    const ids = Array.from(new Set(latest.map(a => a.resource_id || a.resourceId).filter(Boolean)));
                    for (const rid of ids) {
                        try {
                            if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getResource === 'function') {
                                const r = await hubDatabase.getResource(rid);
                                if (r && r.title) resourceNameById[rid] = r.title;
                            }
                        } catch(_) {}
                    }
                } catch(_) {}
                const isUuidLike = (s) => { try { return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(String(s||'')); } catch(_) { return false; } };
                // Load global broadcast announcement (visible to all)
                let broadcastValue = null;
                try {
                    if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getSiteSetting === 'function') {
                        broadcastValue = await hubDatabase.getSiteSetting('broadcast');
                    }
                } catch (_) { broadcastValue = null; }
                // Normalize broadcast structure
                let broadcastItem = '';
                try {
                    let enabled = false; let message = ''; let link = '';
                    if (typeof broadcastValue === 'string') {
                        message = String(broadcastValue || '').trim();
                        enabled = !!message;
                    } else if (broadcastValue && typeof broadcastValue === 'object') {
                        message = String(broadcastValue.message || broadcastValue.text || '').trim();
                        link = String(broadcastValue.link || broadcastValue.url || '').trim();
                        enabled = (broadcastValue.enabled !== false) && !!message;
                    }
                    if (enabled && message) {
                        const linkHtml = link ? ` <a href="${safe(link)}" target="_blank" rel="noopener">Learn more</a>` : '';
                        broadcastItem = `<span class="info-item"><strong>Announcement:</strong> ${safe(message)}${linkHtml}</span>`;
                    }
                } catch (_) { /* ignore */ }
                // Build message HTML items
                const itemsFromActivities = latest.map(a => {
                    const when = (() => { try { return new Date(a.timestamp).toLocaleString(); } catch(_) { return ''; } })();
                    const meta = (a && a.metadata) ? a.metadata : {};
                    const who = a.username || meta.username || a.user || 'Someone';
                    const section = a.section || a.sectionId || a.category || 'general';
                    const sectionLabel = (sectionNames && sectionNames[section]) ? sectionNames[section] : prettyName(section);
                    const action = a.action || a.type || 'updated';
                    const actionLower = String(action).toLowerCase();
                    const resourceId = a.resource_id || a.resourceId || '';
                    let resource = a.title || a.resource || a.description || meta.title || '';
                    // Prefer explicit tab names for tab-related actions
                    if (!resource && (actionLower.includes('tab') || String(a.type||'').toLowerCase().includes('tab'))) {
                        if (meta && (meta.oldName || meta.newName)) {
                            const oldName = meta.oldName || '';
                            const newName = meta.newName || '';
                            resource = oldName && newName ? `${oldName} → ${newName}` : (oldName || newName || '');
                        } else {
                            const tabId = meta.tabId || meta.name || '';
                            resource = tabNameBySection[section] && tabId ? (tabNameBySection[section][tabId] || tabId) : (meta.name || tabId || '');
                        }
                    }
                    // Prefer section names for section-related actions
                    if (!resource && (actionLower.includes('section') || String(a.type||'').toLowerCase().includes('section'))) {
                        if (meta && (meta.oldName || meta.newName)) {
                            const oldName = meta.oldName || '';
                            const newName = meta.newName || '';
                            resource = oldName && newName ? `${oldName} → ${newName}` : (oldName || newName || '');
                        } else {
                            resource = meta.name || sectionLabel || '';
                        }
                    }
                    // Resolve resource title by ID when needed
                    if ((isUuidLike(resource) || (resourceId && resourceId === resource) || !resource) && resourceId) {
                        const resolved = resourceNameById[resourceId];
                        if (resolved) resource = resolved;
                    }
                    return `<span class="info-item"><strong>${safe(who)}</strong> ${safe(action)} ${resource ? `"${safe(resource)}" ` : ''}in <em>${safe(sectionLabel)}</em><span class="info-sep">•</span><span class="muted">${safe(when)}</span></span>`;
                });
                const items = (broadcastItem ? [broadcastItem] : []).concat(itemsFromActivities);
                if (items.length === 0) { infoBar.style.display = 'none'; return; }
                infoBar.style.display = 'flex';
                // Duplicate items to enable seamless loop
                const html = items.join('') + items.join('');
                track.innerHTML = html;
                // Adjust animation duration based on content width for a slower, readable speed
                requestAnimationFrame(() => {
                    const container = track.parentElement; // .info-marquee
                    const containerWidth = container ? container.clientWidth : (window.innerWidth || 800);
                    const width = Math.max(track.scrollWidth / 2, containerWidth); // width of one set
                    const speedPixelsPerSecond = 30; // slower constant speed for readability
                    const duration = Math.max(45, Math.min(240, width / speedPixelsPerSecond));
                    track.style.animationDuration = duration + 's';
                });
            } catch (e) {
                console.warn('rotateInfoBar error', e);
            }
        };

        // Ensure header title and logo are visible; provide fallback icon if logo fails
        window.ensureHeaderVisible = function() {
            try {
                let titleEl = document.querySelector('.header-title h1');
                if (!titleEl) {
                    const logoContainer = document.querySelector('.logo-container');
                    if (logoContainer) {
                        const h1 = document.createElement('h1');
                        h1.textContent = 'Information Hub';
                        logoContainer.appendChild(h1);
                        titleEl = h1;
                    }
                }
                if (titleEl) { titleEl.style.visibility = 'visible'; titleEl.style.color = '#fff'; }
                if (!document.title || !document.title.trim()) {
                    document.title = 'Information Hub - Central Dashboard';
                }
                const logoImg = document.querySelector('.site-logo');
                if (logoImg) {
                    logoImg.style.display = 'inline-block';
                    const fallbackId = 'logoFallbackIcon';
                    const ensureFallback = () => {
                        if (!document.getElementById(fallbackId)) {
                            const icon = document.createElement('i');
                            icon.className = 'fas fa-table-cells-large';
                            icon.id = fallbackId;
                            icon.style.fontSize = '40px';
                            icon.style.color = '#fff';
                            logoImg.insertAdjacentElement('afterend', icon);
                        }
                    };
                    const removeFallback = () => {
                        const f = document.getElementById(fallbackId);
                        if (f) f.remove();
                    };
                    const broken = logoImg.complete && logoImg.naturalWidth === 0;
                    if (broken) {
                        logoImg.style.display = 'none';
                        ensureFallback();
                    } else {
                        logoImg.onerror = () => { logoImg.style.display = 'none'; ensureFallback(); };
                        logoImg.onload = () => { logoImg.style.display = 'inline-block'; removeFallback(); };
                    }
                }
            } catch (_) {}
        };

        // Observe header for unwanted removals/replacements and repair
        window.startHeaderObserver = function() {
            try {
                const headerTitle = document.querySelector('.header-title');
                if (!headerTitle) return;
                const observer = new MutationObserver(() => {
                    try { if (typeof ensureHeaderVisible === 'function') ensureHeaderVisible(); } catch(_) {}
                });
                observer.observe(headerTitle, { childList: true, subtree: true, attributes: true, attributeFilter: ['style', 'class'] });
            } catch(_) {}
        };
        // Open audit log from info bar link - list recent content updates (7 days)
        window.openAuditFromInfoBar = async function(event) {
            try { if (event) event.preventDefault(); } catch(_) {}
            try {
                let activities = [];
                try {
                    if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getActivities === 'function') {
                        activities = await hubDatabase.getActivities(1000, 0);
                    }
                } catch (_) { activities = []; }
                // Also include broadcast announcement at top if present
                let broadcastValue = null;
                try {
                    if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getSiteSetting === 'function') {
                        broadcastValue = await hubDatabase.getSiteSetting('broadcast');
                    }
                } catch (_) { broadcastValue = null; }
                // Filter last 7 days like the marquee
                const now = Date.now();
                const sevenDaysMs = 7 * 24 * 60 * 60 * 1000;
                activities = (activities || []).filter(a => {
                    const t = new Date(a.timestamp).getTime();
                    return Number.isFinite(t) && (now - t) <= sevenDaysMs && (now - t) >= 0;
                });
                // Keep only content activities
                activities = activities.filter(isContentActivity);
                // Sort newest first and take up to 100
                activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                let recent = activities.slice(0, 100);
                const esc = (t) => { const d = document.createElement('div'); d.textContent = t || ''; return d.innerHTML; };
                // Display pretty section names and include action
                let sectionNames = {};
                try { sectionNames = getSectionDisplayNames ? getSectionDisplayNames() : {}; } catch(_) {}
                const prettyName = (key) => {
                    if (!key) return 'General';
                    if (sectionNames && sectionNames[key]) return sectionNames[key];
                    const s = String(key).replace(/-/g, ' ');
                    return s.charAt(0).toUpperCase() + s.slice(1);
                };
                // Augment section names from DB and build per-section tab name maps
                let tabNameBySection = {};
                try {
                    if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getAllSections === 'function') {
                        const secs = await hubDatabase.getAllSections();
                        (secs || []).forEach(s => {
                            try {
                                const sid = s.section_id || s.sectionId || s.id;
                                const nm = s.name || sid;
                                if (sid && nm && (!sectionNames[sid] || sectionNames[sid] === prettyName(sid))) {
                                    sectionNames[sid] = nm;
                                }
                                const cfg = s && typeof s.config === 'object' ? s.config : {};
                                const map = tabNameBySection[sid] || (tabNameBySection[sid] = {});
                                if (Array.isArray(cfg.types)) {
                                    cfg.types.forEach(t => {
                                        const tid = String((t && t.id !== undefined) ? t.id : t);
                                        const tname = String((t && t.name) || tid);
                                        if (tid) map[tid] = tname;
                                    });
                                } else if (Array.isArray(cfg.tabs)) {
                                    const names = Array.isArray(cfg.tab_names) ? cfg.tab_names : [];
                                    cfg.tabs.forEach((tid, i) => {
                                        const k = String(tid || '');
                                        if (k) map[k] = String(names[i] || k);
                                    });
                                }
                            } catch(_) {}
                        });
                    }
                } catch(_) {}
                // Prefetch resource titles for recent items
                const resourceNameById = {};
                try {
                    const ids = Array.from(new Set(recent.map(a => a.resource_id || a.resourceId).filter(Boolean)));
                    for (const rid of ids) {
                        try {
                            if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getResource === 'function') {
                                const r = await hubDatabase.getResource(rid);
                                if (r && r.title) resourceNameById[rid] = r.title;
                            }
                        } catch(_) {}
                    }
                } catch(_) {}
                const isUuidLike = (s) => { try { return /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(String(s||'')); } catch(_) { return false; } };
                // Prepend broadcast if available
                try {
                    let enabled = false; let message = ''; let link = '';
                    if (typeof broadcastValue === 'string') {
                        message = String(broadcastValue || '').trim();
                        enabled = !!message;
                    } else if (broadcastValue && typeof broadcastValue === 'object') {
                        message = String(broadcastValue.message || broadcastValue.text || '').trim();
                        link = String(broadcastValue.link || broadcastValue.url || '').trim();
                        enabled = (broadcastValue.enabled !== false) && !!message;
                    }
                    if (enabled && message) {
                        const linkHtml = link ? ` <a href="${esc(link)}" target="_blank" rel="noopener">Learn more</a>` : '';
                        const header = `<div style="padding:8px 0;border-bottom:1px solid #eee;display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
                            <span><strong>Announcement</strong></span>
                            <span style=\"opacity:.6\">•</span>
                            <span>${esc(message)}${linkHtml}</span>
                        </div>`;
                        recent = [{ __broadcast: header }].concat(recent);
                    }
                } catch(_) {}
                const content = recent.map(a => {
                    if (a && a.__broadcast) return a.__broadcast;
                    const when = (() => { try { return new Date(a.timestamp).toLocaleString(); } catch(_) { return ''; } })();
                    const meta = (a && a.metadata) ? a.metadata : {};
                    const who = esc(a.username || meta.username || a.user || 'Someone');
                    const sectionKey = a.section || a.sectionId || a.category || 'general';
                    const sectionLabelRaw = sectionNames[sectionKey] || prettyName(sectionKey);
                    const section = esc(sectionLabelRaw);
                    const actionRaw = a.action || a.type || 'updated';
                    const action = esc(actionRaw);
                    const resourceId = a.resource_id || a.resourceId || '';
                    let resourceRaw = a.title || a.resource || a.description || meta.title || '';
                    const actionLower = String(actionRaw).toLowerCase();
                    if (!resourceRaw && (actionLower.includes('tab') || String(a.type||'').toLowerCase().includes('tab'))) {
                        if (meta && (meta.oldName || meta.newName)) {
                            const oldName = meta.oldName || '';
                            const newName = meta.newName || '';
                            resourceRaw = oldName && newName ? `${oldName} → ${newName}` : (oldName || newName || '');
                        } else {
                            const tabId = meta.tabId || meta.name || '';
                            resourceRaw = tabNameBySection[sectionKey] && tabId ? (tabNameBySection[sectionKey][tabId] || tabId) : (meta.name || tabId || '');
                        }
                    }
                    if (!resourceRaw && (actionLower.includes('section') || String(a.type||'').toLowerCase().includes('section'))) {
                        if (meta && (meta.oldName || meta.newName)) {
                            const oldName = meta.oldName || '';
                            const newName = meta.newName || '';
                            resourceRaw = oldName && newName ? `${oldName} → ${newName}` : (oldName || newName || '');
                        } else {
                            resourceRaw = meta.name || sectionLabelRaw || '';
                        }
                    }
                    if ((isUuidLike(resourceRaw) || (resourceId && resourceId === resourceRaw) || !resourceRaw) && resourceId) {
                        const resolved = resourceNameById[resourceId];
                        if (resolved) resourceRaw = resolved;
                    }
                    const resource = esc(resourceRaw);
                    return `<div style=\"padding:8px 0;border-bottom:1px solid #eee;display:flex;gap:10px;flex-wrap:wrap;align-items:center;\">\n                        <span><strong>${who}</strong></span>\n                        <span style=\\\"opacity:.6\\\">•</span>\n                        <span>${action}</span>\n                        <span style=\\\"opacity:.6\\\">•</span>\n                        <span>${section}</span>\n                        ${resource ? `<span style=\\\"opacity:.6\\\">•</span><span>${resource}</span>` : ''}\n                        <span style=\\\"margin-left:auto;color:#999;font-size:0.85rem;\\\">${esc(when)}</span>\n                    </div>`;
                }).join('');
                const wrapper = document.createElement('div');
                wrapper.className = 'modal';
                wrapper.style.display = 'block';
                wrapper.innerHTML = `
                    <div class=\"modal-content\" style=\"max-width:700px;\">
                        <div class=\"modal-header\"><h2>Recent Updates (7 days)</h2><span class=\"close\" onclick=\"this.closest('.modal').remove()\">&times;</span></div>
                        <div class=\"modal-body\" style=\"max-height:60vh;overflow:auto;padding:20px;\">\n                            <div style=\\\"display:flex;gap:10px;align-items:center;font-weight:600;border-bottom:1px solid #e9ecef;padding:6px 0;margin-bottom:6px;\\\">\n                                <span>Who</span>\n                                <span style=\\\"opacity:.6\\\">•</span>\n                                <span>Action</span>\n                                <span style=\\\"opacity:.6\\\">•</span>\n                                <span>Section</span>\n                                <span style=\\\"opacity:.6\\\">•</span>\n                                <span>Resource</span>\n                                <span style=\\\"margin-left:auto;\\\">When</span>\n                            </div>\n                            ${content || '<div>No recent updates.</div>'}\n                        </div>
                    </div>`;
                document.body.appendChild(wrapper);
            } catch (e) { alert('Unable to open updates: ' + e.message); }
        };

        // Fallback navigation if the main app binding didn't attach
        if (typeof window.navigateToSection !== 'function') {
            window.navigateToSection = function(sectionId) {
                try {
                    localStorage.setItem('currentSection', sectionId);
                } catch (_) {}
                window.location.href = 'section.html?section=' + encodeURIComponent(sectionId);
            };
        }
        
        
        
        
        // Show section manager directly
        window.showSectionManager = function() {
            console.log('Opening section manager...');
            
            // Load sections list
            loadSectionsList();
            
            // Open admin panel and switch to sections tab
            const adminModal = document.getElementById('adminPanelModal');
            if (adminModal) {
                adminModal.style.display = 'block';
                
                console.log('Section manager opened');
            } else {
                alert('Admin panel not found. Please try the full admin panel first.');
            }
        };
        
        // Simple logout function
        window.logout = async function() {
            console.log('Logout called');
            try {
                // Sign out from Supabase
                const { error } = await supabase.auth.signOut();
                if (error) {
                    console.error('Error signing out:', error);
                } else {
                    console.log('Signed out from Supabase');
                }
                
                // Redirect to login page
                window.location.href = 'auth.html';
                console.log('Redirecting to login page');
            } catch (error) {
                console.error('Logout error:', error);
                // Force redirect even if there's an error
                window.location.href = 'auth.html';
            }
        };
        
        
        // Quick action functions
        window.showAllSections = function() {
            // Create a modal to show all sections
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>All Sections Overview</h2>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="sections-overview">
                            <div class="section-item">
                                <i class="fas fa-calculator"></i>
                                <h3>Costing</h3>
                                <p>Financial analysis, cost management, and budgeting resources</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-truck"></i>
                                <h3>Supply Planning</h3>
                                <p>Supply chain management, inventory planning, and logistics</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-cogs"></i>
                                <h3>Operations</h3>
                                <p>Operational procedures, workflows, and process management</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-check-circle"></i>
                                <h3>Quality Management</h3>
                                <p>Quality control, assurance, and compliance procedures</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-users"></i>
                                <h3>Human Resources</h3>
                                <p>HR policies, procedures, and employee management resources</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-laptop-code"></i>
                                <h3>IT & Technology</h3>
                                <p>Technical documentation, system guides, and IT procedures</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-chart-line"></i>
                                <h3>Sales & Marketing</h3>
                                <p>Sales processes, marketing strategies, and customer management</p>
                            </div>
                            <div class="section-item">
                                <i class="fas fa-gavel"></i>
                                <h3>Compliance & Legal</h3>
                                <p>Regulatory compliance, legal procedures, and policy management</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        };
        
        window.searchAcrossHub = function() {
            const searchTerm = prompt('Enter search term to search across all sections:');
            if (searchTerm) {
                // Simple search implementation
                const results = [];
                const sections = ['costing', 'supply-planning', 'operations', 'quality', 'hr', 'it', 'sales', 'compliance'];
                
                sections.forEach(section => {
                    const sectionData = localStorage.getItem(`section_${section}`);
                    if (sectionData) {
                        const data = JSON.parse(sectionData);
                        // Search in playbooks, boxLinks, and dashboards
                        ['playbooks', 'boxLinks', 'dashboards'].forEach(type => {
                            if (data[type]) {
                                data[type].forEach(item => {
                                    if (item.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                        item.description.toLowerCase().includes(searchTerm.toLowerCase())) {
                                        results.push({
                                            section: section,
                                            type: type,
                                            title: item.title,
                                            url: item.url
                                        });
                                    }
                                });
                            }
                        });
                    }
                });
                
                if (results.length > 0) {
                    let resultText = `Found ${results.length} results for "${searchTerm}":\n\n`;
                    results.forEach(result => {
                        resultText += `• ${result.title} (${result.section} - ${result.type})\n`;
                    });
                    alert(resultText);
                } else {
                    alert(`No results found for "${searchTerm}"`);
                }
            }
        };
        
        window.showRecentActivity = async function() {
            let activities = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    activities = await hubDatabase.getActivities();
                }
            } catch (e) {
                console.error('Error loading activities:', e);
            }
            
            if (activities.length === 0) {
                alert('No recent activity found.');
                return;
            }
            
            let activityText = 'Recent Activity:\n\n';
            activities.slice(0, 10).forEach(activity => {
                const date = new Date(activity.timestamp).toLocaleString();
                activityText += `• ${activity.username}: ${activity.action} - ${activity.description}\n   ${date}\n\n`;
            });
            alert(activityText);
        };
        window.openAdminPanel = async function() {
            try {
                console.log('showAdminPanel called');
                // Use the initialized Supabase client
                if (!window.supabaseClient) {
                    alert('Please log in to access admin panel.');
                    return;
                }
                const { data: { user } } = await window.supabaseClient.auth.getUser();
                if (!user) {
                    alert('Please log in to access admin panel.');
                    return;
                }
                // Load role/permissions from profiles
                let role = 'viewer';
                let permissions = {};
                try {
                    const { data: profile } = await window.supabaseClient
                        .from('profiles')
                        .select('role, permissions')
                        .eq('id', user.id)
                        .single();
                    if (profile) {
                        role = profile.role || role;
                        permissions = (profile.permissions && typeof profile.permissions === 'object') ? profile.permissions : {};
                    }
                } catch (e) { console.warn('Profile fetch failed', e); }

                const roleLower = String(role||'').toLowerCase();
                const isAdmin = roleLower === 'admin';
                const isEditor = roleLower === 'editor';
                // Strict role-based gating: only admins and editors can open the admin panel
                if (!(isAdmin || isEditor)) {
                    alert('Only administrators or editors can access the admin panel.');
                    return;
                }

                console.log('Opening admin panel modal...');
                // Show the admin panel modal ASAP
                const adminModal = document.getElementById('adminPanelModal');
                if (!adminModal) {
                    alert('Admin panel not found on the page.');
                    return;
                }
                adminModal.style.display = 'block';
                adminModal.style.zIndex = '9999';
                
                // Defer data loading to avoid blocking UI and reduce errors
                setTimeout(() => {
                    try { if (typeof renderCurrentUserSummary === 'function') renderCurrentUserSummary(); } catch (e) { console.error('renderCurrentUserSummary error', e); }
                    // Only admins load Users/Permissions/Audit data
                    if (isAdmin) {
                        try { if (typeof loadUsersList === 'function') loadUsersList(); } catch (e) { console.error('loadUsersList error', e); }
                        try { if (typeof loadPermissionUserList === 'function') loadPermissionUserList(); } catch (e) { console.error('loadPermissionUserList error', e); }
                        try { if (typeof loadAuditLog === 'function') loadAuditLog(); } catch (e) { console.error('loadAuditLog error', e); }
                    }
                }, 0);
                
                // After modal is visible, manage Assignments/Manage Sections tabs by role
                const usersNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('users')\"]");
                const usersContent = document.getElementById('users-tab');
                const permissionsNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('permissions')\"]");
                const permissionsContent = document.getElementById('permissions-tab');
                const auditNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('audit')\"]");
                const auditContent = document.getElementById('audit-tab');
                const assignmentsNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('assignments')\"]");
                const assignmentsContent = document.getElementById('assignments-tab');
                const manageSectionsNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('sections')\"]");
                const manageSectionsContent = document.getElementById('sections-tab');
                const exportNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('export')\"]");
                const exportContent = document.getElementById('export-tab');
                const importNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('import')\"]");
                const importContent = document.getElementById('import-tab');
                const diagNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('diagnostics')\"]");
                const diagContent = document.getElementById('diagnostics-tab');

                setTimeout(() => { try {
                    // Admin-only tabs
                    const showAdminOnly = isAdmin ? '' : 'none';
                    if (usersNavTab) usersNavTab.style.display = showAdminOnly;
                    if (usersContent) usersContent.style.display = showAdminOnly;
                    if (auditNavTab) auditNavTab.style.display = showAdminOnly;
                    if (auditContent) auditContent.style.display = showAdminOnly;
                    if (assignmentsNavTab) assignmentsNavTab.style.display = showAdminOnly;
                    if (assignmentsContent) assignmentsContent.style.display = showAdminOnly;
                    if (exportNavTab) exportNavTab.style.display = showAdminOnly;
                    if (exportContent) exportContent.style.display = showAdminOnly;
                    if (importNavTab) importNavTab.style.display = showAdminOnly;
                    if (importContent) importContent.style.display = showAdminOnly;
                    if (diagNavTab) diagNavTab.style.display = showAdminOnly;
                    if (diagContent) diagContent.style.display = showAdminOnly;

                    // Permissions tab for admins and editors
                    const showPerms = (isAdmin || isEditor) ? '' : 'none';
                    if (permissionsNavTab) permissionsNavTab.style.display = showPerms;
                    if (permissionsContent) permissionsContent.style.display = showPerms;

                    // Manage Sections/Assignments visible for admins only
                    if (!isAdmin) {
                        if (manageSectionsNavTab) manageSectionsNavTab.style.display = 'none';
                        if (manageSectionsContent) manageSectionsContent.style.display = 'none';
                        if (assignmentsNavTab) assignmentsNavTab.style.display = 'none';
                        if (assignmentsContent) assignmentsContent.style.display = 'none';
                    } else {
                        if (manageSectionsNavTab) manageSectionsNavTab.style.display = '';
                        if (manageSectionsContent) manageSectionsContent.style.display = '';
                        if (assignmentsNavTab) assignmentsNavTab.style.display = '';
                        if (assignmentsContent) assignmentsContent.style.display = '';
                    }

                    // Default active tab
                    if (isAdmin) {
                        if (permissionsContent) permissionsContent.classList.remove('active');
                        if (usersContent) usersContent.classList.add('active');
                        try { if (typeof loadUsersList === 'function') loadUsersList(); } catch(_) {}
                    } else if (isEditor) {
                        if (usersContent) usersContent.classList.remove('active');
                        if (permissionsContent) permissionsContent.classList.add('active');
                        try { if (typeof loadPermissionUserList === 'function') loadPermissionUserList(); } catch(_) {}
                    }
                } catch (e) { console.error('role-based tab visibility error', e); } }, 0);
                
                // Ensure scrolling works
                setTimeout(() => {
                    const adminContent = adminModal.querySelector('.admin-content');
                    if (adminContent) {
                        adminContent.style.overflowY = 'auto';
                        adminContent.style.maxHeight = '70vh';
                    }
                }, 100);
            } catch (e) {
                console.error('Error showing admin panel:', e);
                alert('Failed to open User Management. Please refresh and try again.');
            }
        };
        // Backward-compatible alias
        window.showAdminPanel = window.openAdminPanel;
        // Ensure tab switching works and triggers data loading
        if (typeof window.switchAdminTab !== 'function') {
            window.switchAdminTab = function(tabName) {
                console.log('Switching to tab:', tabName);
                
                // Update tab appearance
                document.querySelectorAll('.admin-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                try {
                    const selectedNav = document.querySelector(`.admin-tab[onclick="switchAdminTab('${tabName}')"]`);
                    if (selectedNav) selectedNav.classList.add('active');
                } catch(_) {}

                // Show/hide content sections
                document.querySelectorAll('.admin-tab-content').forEach(content => {
                    content.classList.remove('active');
                    try { content.style.display = 'none'; } catch(_) {}
                });
                
                const targetTab = document.getElementById(`${tabName}-tab`);
                if (targetTab) {
                    targetTab.classList.add('active');
                    try { targetTab.style.display = 'block'; } catch(_) {}
                    console.log('Tab content activated:', tabName);
                } else {
                    console.error('Tab content not found:', `${tabName}-tab`);
                }

                // Load specific tab content
                if (tabName === 'users') {
                    try { renderCurrentUserSummary(); } catch (e) { console.warn('renderCurrentUserSummary error', e); }
                    loadUsersList();
                } else if (tabName === 'permissions') {
                    loadPermissionUserList();
                } else if (tabName === 'audit') {
                    loadAuditLog();
                } else if (tabName === 'sections') {
                    console.log('Loading sections list...');
                    loadSectionsList();
                } else if (tabName === 'assignments') {
                    console.log('Loading section assignments...');
                    try { const si = document.getElementById('assignmentUserSearchInput'); if (si) si.value = ''; } catch(_) {}
                    // Always render immediately (auto-loads if cache is empty)
                    try { if (typeof renderAssignmentsList === 'function') { renderAssignmentsList(); setTimeout(() => { try { renderAssignmentsList(); } catch(_) {} }, 0); } } catch(_) {}
                    // Then ensure data load kicks off
                    try { if (typeof loadSectionAssignments === 'function' && !window.__assignmentsLoading) { loadSectionAssignments(); } } catch(_) {}
                }
            };
        }

        // Admin diagnostics runner
        window.runAdminDiagnostics = async function() {
            const out = document.getElementById('diagnosticsOutput');
            const log = (msg) => { if (out) out.innerHTML += `<div>${msg}</div>`; };
            if (out) out.innerHTML = '';
            try {
                log('<b>0) Environment</b>');
                log(`vers: app=${(window.appVersion||'n/a')} time=${new Date().toISOString()}`);
                log(`flags: hubDBReady=${!!window.hubDatabaseReady}`);
                
                log('<b>1) Supabase client</b>');
                if (!window.supabaseClient) { log('❌ Not initialized'); return; } else { log('✅ Initialized'); }

                log('<b>2) Auth user</b>');
                const { data: { user: me } } = await window.supabaseClient.auth.getUser();
                if (!me) { log('❌ Not authenticated'); return; } else { log(`✅ ${me.email || me.id}`); }

                log('<b>3) Profile (role/permissions)</b>');
                const { data: myProfile } = await window.supabaseClient
                    .from('profiles')
                    .select('id, role, permissions')
                    .eq('id', me.id)
                    .single();
                if (!myProfile) { log('❌ Profile not found'); return; } else { log(`✅ Role: ${myProfile.role}`); }

                log('<b>4) Sections read</b>');
                const { data: secs, error: sErr } = await window.supabaseClient
                    .from('sections')
                    .select('section_id, name, config')
                    .order('name', { ascending: true });
                if (sErr) { log('❌ ' + sErr.message); } else { log('✅ ' + (secs?.length || 0) + ' rows'); }

                // Variables snapshot for troubleshooting data flows
                log('<b>5) Variables snapshot</b>');
                try {
                    const usersFromDb = (window.hubDatabase && window.hubDatabaseReady && hubDatabase.getAllUsers) ? (await hubDatabase.getAllUsers()) : [];
                    const sectionsFromDb = (window.hubDatabase && window.hubDatabaseReady && hubDatabase.getAllSections) ? (await hubDatabase.getAllSections()) : [];
                    const sectionIdsAvail = await (async () => { try { return await getAllAvailableSections(); } catch(_) { return []; }})();
                    const sectionNamesMap = await (async () => { try { return await getSectionDisplayNames(); } catch(_) { return {}; }})();
                    log(`users(count) = ${Array.isArray(usersFromDb) ? usersFromDb.length : 0}`);
                    log(`sections(count) = ${Array.isArray(sectionsFromDb) ? sectionsFromDb.length : 0}`);
                    log(`getAllAvailableSections(count) = ${Array.isArray(sectionIdsAvail) ? sectionIdsAvail.length : 0}`);
                    log(`getSectionDisplayNames(keys) = ${Object.keys(sectionNamesMap||{}).length}`);
                    // Direct Supabase counts for cross-check
                    try {
                        const { count: profileCount } = await window.supabaseClient
                            .from('profiles')
                            .select('id', { count: 'exact', head: true });
                        const { count: sectionCount } = await window.supabaseClient
                            .from('sections')
                            .select('section_id', { count: 'exact', head: true });
                        log(`profiles(count via Supabase) = ${profileCount ?? 'n/a'}`);
                        log(`sections(count via Supabase) = ${sectionCount ?? 'n/a'}`);
                    } catch(_) {}
                    if (Array.isArray(sectionsFromDb) && sectionsFromDb.length > 0) {
                        const sample = sectionsFromDb.slice(0, 3).map(s => s.section_id || s.id).join(', ');
                        log(`sections(sample ids) = ${sample}`);
                    }
                } catch (snapErr) { log('⚠️ Snapshot error: ' + (snapErr?.message||snapErr)); }

                log('<b>6) No-op profile update (self)</b>');
                const { error: uErr } = await window.supabaseClient
                    .from('profiles')
                    .update({ permissions: myProfile.permissions || {} })
                    .eq('id', me.id);
                if (uErr) { log('❌ ' + uErr.message); } else { log('✅ OK'); }

                log('<b>7) Temp section create/delete</b>');
                const tempId = 'diag-' + Math.random().toString(36).slice(2, 8);
                const { error: cErr } = await window.supabaseClient
                    .from('sections')
                    .insert({ section_id: tempId, name: 'Diagnostics Temp', icon: 'fas fa-cube', config: { visible: false, order: 999 } });
                if (cErr) { log('⚠️ Create failed: ' + cErr.message); }
                const { error: dErr } = await window.supabaseClient
                    .from('sections')
                    .delete()
                    .eq('section_id', tempId);
                if (dErr) { log('⚠️ Delete failed: ' + dErr.message); }
                if (!cErr && !dErr) log('✅ Create/Delete');

                log('<b>Done.</b>');
            } catch (e) {
                log('❌ Exception: ' + (e?.message || e));
            }
        };
        
        window.exportAllData = async function() {
            try {
                if (!(window.excelExporter && excelExporter.exportToExcel)) {
                    alert('Export not available: exporter not loaded');
                    return;
                }
                const result = await excelExporter.exportToExcel();
                if (!result.success) {
                    alert('Export failed: ' + (result.error || 'Unknown error'));
                }
            } catch (e) {
                alert('Export failed: ' + (e && e.message ? e.message : String(e)));
            }
        };
        // Robust Backup JSON fallback (works even if DB is not ready)
        if (typeof window.backupJson !== 'function') {
            window.backupJson = async function() {
                try {
                    // Require Supabase + admin/manager
                    if (!window.supabaseClient) throw new Error('Supabase not initialized');
                    const { data: { user: me } } = await window.supabaseClient.auth.getUser();
                    if (!me) throw new Error('Not authenticated');
                    const { data: prof, error: pErr } = await window.supabaseClient
                        .from('profiles')
                        .select('role, permissions')
                        .eq('id', me.id)
                        .single();
                    if (pErr) throw pErr;
                    const role = String(prof?.role || '').toLowerCase();
                    const canManage = !!(prof && prof.permissions && prof.permissions.canManageUsers);
                    if (!(role === 'admin' || canManage)) throw new Error('Only admins can perform backups');

                    // Export database state only
                    let payload = null;
                    if (window.hubDatabase && typeof hubDatabase.exportRawState === 'function') {
                        payload = await hubDatabase.exportRawState();
                    }
                    if (!payload) {
                        throw new Error('Database unavailable for backup');
                    }

                    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `Information_Hub_Backup_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error('Backup JSON failed', e);
                    alert('Backup failed: ' + e.message);
                }
            };
        }
        // Robust Restore JSON fallback (works even if DB is not ready)
        if (typeof window.restoreJson !== 'function') {
            window.restoreJson = async function() {
                try {
                    const input = document.createElement('input');
                    input.type = 'file';
                    input.accept = 'application/json,.json';
                    input.onchange = async (e) => {
                        const file = e.target.files && e.target.files[0];
                        if (!file) return;
                        let text = '';
                        try {
                            text = await file.text();
                        } catch (readErr) {
                            alert('Failed to read file: ' + readErr.message);
                            return;
                        }
                        let data = null;
                        try {
                            data = JSON.parse(text);
                        } catch (parseErr) {
                            alert('Invalid JSON: ' + parseErr.message);
                            return;
                        }
                        if (!confirm('This will overwrite data. Continue?')) return;

                        // Progress overlay UI
                        const overlay = document.createElement('div');
                        overlay.id = 'restoreProgressOverlay';
                        overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,.6);z-index:10000;display:flex;align-items:center;justify-content:center;color:#fff;';
                        overlay.innerHTML = `
<div style="width:680px;max-width:92%;background:#111;border:1px solid #333;border-radius:10px;padding:16px 16px 10px 16px;box-shadow:0 10px 30px rgba(0,0,0,.5);">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;margin-bottom:10px;">
    <h3 style="margin:0;font-size:16px;">Restoring backup...</h3>
    <button id="restoreCancelBtn" class="btn btn-secondary" style="display:none;">Cancel</button>
  </div>
  <div style="background:#222;border-radius:8px;padding:10px;">
    <div id="restoreProgressBar" style="height:8px;background:#333;border-radius:6px;overflow:hidden;margin-bottom:10px;">
      <div id="restoreProgressFill" style="height:100%;width:0;background:linear-gradient(90deg,#00c6ff,#0072ff);"></div>
    </div>
    <div id="restoreSummary" style="font-size:12px;color:#bbb;margin-bottom:8px;">Preparing...</div>
    <div id="restoreLog" style="max-height:200px;overflow:auto;background:#0c0c0c;border:1px solid #222;border-radius:6px;padding:8px;font-family:ui-monospace, Menlo, Consolas, monospace;font-size:12px;"></div>
  </div>
</div>`;
                        document.body.appendChild(overlay);
                        const logEl = overlay.querySelector('#restoreLog');
                        const sumEl = overlay.querySelector('#restoreSummary');
                        const fillEl = overlay.querySelector('#restoreProgressFill');
                        const log = (msg) => { if (logEl) { const div = document.createElement('div'); div.textContent = msg; logEl.appendChild(div); logEl.scrollTop = logEl.scrollHeight; } };
                        const setPct = (p) => { if (fillEl) fillEl.style.width = Math.max(0, Math.min(100, p)) + '%'; };

                        let totals = { sections:0, resources:0, views:0, siteSettings:0, users:0 };
                        let done = { sections:0, resources:0, views:0, siteSettings:0, users:0 };
                        const updateSummary = () => {
                            if (!sumEl) return;
                            const parts = [];
                            const add = (k,lbl) => { const d = done[k]||0, t = totals[k]||0; if (t>0) parts.push(`${lbl}: ${d}/${t}`); };
                            add('sections','Sections'); add('resources','Resources'); add('views','Views'); add('siteSettings','Settings'); add('users','Users');
                            sumEl.textContent = parts.length ? parts.join(' • ') : 'Preparing...';
                            const tTotal = Object.values(totals).reduce((a,b)=>a+(b||0),0);
                            const dTotal = Object.values(done).reduce((a,b)=>a+(b||0),0);
                            setPct(tTotal>0 ? (dTotal*100/tTotal) : 10);
                        };

                        const onProgress = (evt) => {
                            try {
                                if (!evt) return;
                                if (evt.step === 'start') {
                                    totals = Object.assign(totals, evt.counts || {});
                                    log(`Start: ${JSON.stringify(evt.counts||{})}`);
                                    updateSummary();
                                    return;
                                }
                                if (evt.step === 'elevated') { log('Permissions elevated for restore'); return; }
                                if (evt.step === 'section') { if (evt.status==='ok') { done.sections++; log(`Section ✓ ${evt.id}`); } else { log(`Section ✗ ${evt.id}: ${evt.error}`); } updateSummary(); return; }
                                if (evt.step === 'resource') { if (evt.status==='ok') { done.resources++; log(`Resource ✓ ${evt.id||'?'} (section ${evt.sectionId})`); } else { log(`Resource ✗ ${evt.id||'?'}: ${evt.error}`); } updateSummary(); return; }
                                if (evt.step === 'view') { if (evt.status==='ok') { done.views++; } updateSummary(); return; }
                                if (evt.step === 'siteSetting') { if (evt.status==='ok') { done.siteSettings++; log(`Setting ✓ ${evt.key}`); } else { log(`Setting ✗ ${evt.key}: ${evt.error}`); } updateSummary(); return; }
                                if (evt.step === 'user') { if (evt.status==='ok') { done.users++; log(`User ✓ ${evt.id}`); } else { log(`User ✗ ${evt.id}: ${evt.error}`); } updateSummary(); return; }
                                if (evt.step === 'reverted') { log('Permissions reverted'); return; }
                                if (evt.step === 'done') { log('Restore complete'); setPct(100); return; }
                                if (evt.step === 'error') { log(`Error: ${evt.error}`); return; }
                            } catch(_) {}
                        };

                        let importedToDb = false;
                        try {
                            if (window.hubDatabase && typeof hubDatabase.importRawState === 'function') {
                                await hubDatabase.importRawState(data, { onProgress });
                                importedToDb = true;
                            }
                        } catch (dbErr) {
                            console.warn('DB import failed:', dbErr);
                            log('DB import failed: ' + (dbErr && dbErr.message ? dbErr.message : String(dbErr)));
                        }

                        try { if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay); } catch(_) {}

                        if (!importedToDb) {
                            alert('Restore failed. See console for details.');
                            return;
                        }

                        try { if (typeof updateUserInterface === 'function') updateUserInterface(); } catch(_) {}
                        try { if (typeof updateSectionStats === 'function') await updateSectionStats(); } catch(_) {}
                        alert('Restore complete. The page will reload to apply changes.');
                        window.location.reload();
                    };
                    input.click();
                } catch (e) {
                    console.error('Restore JSON failed', e);
                    alert('Restore failed: ' + e.message);
                }
            };
        }
        window.showUserProfile = async function() {
            // Check if user is authenticated
            const { data: { user }, error } = await supabase.auth.getUser();
            if (error || !user) {
                alert('Please log in to view profile.');
                return;
            }
            
            // Get full user profile from database
            const { data: profile, error: profileError } = await supabase
                .from('profiles')
                .select('*')
                .eq('id', user.id)
                .single();
            
            if (profileError || !profile) {
                alert('Error loading user profile.');
                return;
            }
            
            const profileText = `User Profile:
Username: ${profile.username}
Role: ${profile.role}
Name: ${profile.name || 'Not provided'}
Email: ${profile.email || 'Not provided'}
Accessible Sections:
${(profile.permissions?.sections || []).map(s => '• ' + s.replace('-', ' ').toUpperCase()).join('\n')}
Permissions:
• Manage Users: ${profile.permissions?.canManageUsers ? 'Yes' : 'No'}
• Edit All Sections: ${profile.permissions?.canEditAllSections ? 'Yes' : 'No'}
• Delete Resources: ${profile.permissions?.canDeleteResources ? 'Yes' : 'No'}
• View Audit Log: ${profile.permissions?.canViewAuditLog ? 'Yes' : 'No'}`;
            
            alert(profileText);
        };
        
        // Make updateSectionStats available globally
        window.updateSectionStats = updateSectionStats;

        // Robust Add User handler available from Admin panel button
        window.adminAddUser = function() {
            try {
                // Primary paths
                if (window.informationHub && typeof informationHub.addUser === 'function') {
                    return informationHub.addUser();
                }
                if (typeof window.addUser === 'function') {
                    return window.addUser();
                }

                // Helper to load a script once
                function loadScriptOnce(src) {
                    return new Promise((resolve, reject) => {
                        const existing = Array.from(document.scripts).find(s => (s.src || '').includes(src));
                        if (existing) {
                            // If already present, wait a tick to allow it to finish parsing
                            return setTimeout(resolve, 50);
                        }
                        const s = document.createElement('script');
                        s.src = src;
                        s.onload = () => resolve();
                        s.onerror = () => reject(new Error('Failed to load ' + src));
                        document.head.appendChild(s);
                    });
                }

                // Try immediate initialization if class is available
                if (window.InformationHub) {
                    try {
                        if (!window.informationHub) window.informationHub = new InformationHub();
                        if (window.informationHub && typeof informationHub.addUser === 'function') {
                            return informationHub.addUser();
                        }
                    } catch (e) { console.warn('InformationHub init attempt failed:', e); }
                }

                // Ensure hub script is loaded, then retry with backoff
                const ensureReady = async () => {
                    try {
                        if (!window.InformationHub) {
                            // await loadScriptOnce('hub-script.js');
                        }
                    } catch (e) {
                        console.error('hub-script.js load error', e);
                    }

                    let attempts = 0;
                    const maxAttempts = 6;
                    const step = () => {
                        attempts++;
                        try {
                            if (!window.informationHub && window.InformationHub) {
                                try { window.informationHub = new InformationHub(); } catch (e) { console.warn('InformationHub ctor failed:', e); }
                            }
                            if (window.informationHub && typeof informationHub.addUser === 'function') {
                                return informationHub.addUser();
                            }
                            if (typeof window.addUser === 'function') {
                                return window.addUser();
                            }
                            if (attempts < maxAttempts) {
                                return setTimeout(step, 200 * attempts);
                            }
                            console.error('Diagnostics:', {
                                informationHub: !!window.informationHub,
                                hasAddUserOnHub: window.informationHub ? typeof window.informationHub.addUser : 'no hub',
                                InformationHubClass: !!window.InformationHub,
                                windowAddUser: typeof window.addUser
                            });
                            alert('Add User function not available. Please ensure the system is properly initialized.');
                        } catch (err) {
                            alert('Add User failed: ' + err.message);
                        }
                    };
                    step();
                };
                ensureReady();
            } catch (e) {
                alert('Add User failed: ' + e.message);
            }
        };

        // Open Add User modal
        window.openAddUserModal = async function() {
            try {
                // Get current user from Supabase
                const { data: { user }, error } = await (window.supabaseClient ? window.supabaseClient.auth.getUser() : { data: { user: null }, error: new Error('No client') });
                if (error || !user) {
                    alert('Please log in to add users.');
                    return;
                }
                
                // Get full user profile to check role
                const { data: profile, error: profileError } = await window.supabaseClient
                    .from('profiles')
                    .select('id, role, permissions')
                    .eq('id', user.id)
                    .single();
                
                if (profileError || !profile || (String(profile.role||'').toLowerCase() !== 'admin' && profile.permissions?.canManageUsers !== true)) {
                    return alert('Only administrators or permitted editors can add users.');
                }
                const modal = document.getElementById('addUserModal');
                if (modal) {
                    // Re-layout form for clarity
                    const body = modal.querySelector('.modal-body');
                    if (body) {
                        body.style.display = 'block';
                    }
                    const form = modal.querySelector('#addUserForm');
                    if (form) {
                        form.style.display = 'grid';
                        form.style.gridTemplateColumns = '1fr 1fr';
                        form.style.gap = '10px 16px';
                        const actions = form.querySelector('.form-actions');
                        if (actions) { actions.style.gridColumn = '1 / -1'; }
                    }
                    modal.style.display = 'block';
                }
            } catch (e) { alert('Unable to open Add User form: ' + e.message); }
        };

        // Submit Add User form
        window.submitAddUser = async function(event) {
            try {
                if (event && event.preventDefault) event.preventDefault();
                const username = (document.getElementById('newUsername')?.value || '').trim();
                const password = (document.getElementById('newPassword')?.value || '').trim();
                const name = (document.getElementById('newName')?.value || '').trim();
                const email = (document.getElementById('newEmail')?.value || '').trim();
                const role = (document.getElementById('newRole')?.value || 'user').toLowerCase();
                if (!email || !password || !role) {
                    alert('Please fill in email, password, and role.');
                    return false;
                }
                // Determine visible sections to seed viewer permissions
                let sectionIds = [];
                try {
                    const rows = window.hubDatabase && window.hubDatabaseReady ? await hubDatabase.getAllSections() : [];
                    sectionIds = (rows || []).filter(s => !s.config || s.config.visible !== false).map(s => s.section_id || s.sectionId || s.id).filter(Boolean);
                } catch(_) { sectionIds = []; }
                if (!window.supabaseClient) { alert('Supabase not initialized'); return false; }

                // If a profile with this email already exists, just update role/permissions
                const { data: existingProfiles } = await window.supabaseClient
                    .from('profiles')
                    .select('id, email, username')
                    .eq('email', email)
                    .limit(1);
                let targetUserId = existingProfiles && existingProfiles[0] ? existingProfiles[0].id : null;

                // If not existing, create auth user via signUp (may require email confirmation settings)
                if (!targetUserId) {
                    const { data: signUpData, error: signUpErr } = await window.supabaseClient.auth.signUp({
                        email,
                        password,
                        options: { data: { username: username || email.split('@')[0], name } }
                    });
                    if (signUpErr) { alert('Sign up failed: ' + signUpErr.message); return false; }
                    targetUserId = signUpData?.user?.id || null;
                    if (!targetUserId) {
                        alert('Sign up created user without id. Check email confirmation settings.');
                        return false;
                    }
                }

                // Upsert profile with role viewer and permissions (view all visible)
                const profilePayload = {
                    id: targetUserId,
                    username: username || email.split('@')[0],
                    role: 'viewer',
                    name: name || username || email.split('@')[0],
                    email,
                    permissions: {
                        sections: sectionIds.length > 0 ? sectionIds : ['*'],
                        editableSections: [],
                        canViewAllSections: true,
                        canEditAllSections: false,
                        canManageUsers: false,
                        canDeleteResources: false,
                        canViewAuditLog: false,
                        canManageRoles: false
                    }
                };
                const { error: upsertErr } = await window.supabaseClient
                    .from('profiles')
                    .upsert(profilePayload, { onConflict: 'id' });
                if (upsertErr) { alert('Profile save failed: ' + upsertErr.message); return false; }

                try { if (typeof loadUsersList === 'function') loadUsersList(); } catch(_){}
                const modal = document.getElementById('addUserModal');
                if (modal) modal.style.display = 'none';
                alert('User added successfully');
                return false;
            } catch (e) {
                alert('Add User failed: ' + e.message);
                return false;
            }
        };
        
        // Role hierarchy management functions
        window.canManageUser = function(currentUser, targetUser) {
            try {
                const myRole = String(currentUser?.role || '').toLowerCase();
                const targetId = String(targetUser?.id || '');
                if (!myRole) return false;
                // Admin can manage everyone
                if (myRole === 'admin') return true;
                // Can always manage self
                if (currentUser && targetId && String(currentUser.id||'') === targetId) return true;
                // Viewers (or unknown) cannot manage anyone
                if (myRole === 'viewer' || myRole === 'user') return false;
                // Editors: only manage users who share at least one section with the editor's editableSections
                if (myRole === 'editor') {
                    const myEditable = Array.isArray(currentUser?.permissions?.editableSections) ? currentUser.permissions.editableSections : [];
                    if (!myEditable || myEditable.length === 0) return false;
                    const targetSections = Array.isArray(targetUser?.permissions?.sections) ? targetUser.permissions.sections : [];
                    if (targetSections.includes('*')) return true; // target sees all; overlap implied
                    const mySet = new Set(myEditable);
                    for (const s of targetSections) {
                        if (mySet.has(s)) return true;
                    }
                    return false;
                }
            } catch (_) {}
            return false;
        };
        
        window.canChangeUserRole = function(currentUser, targetUser, newRole) {
            // Admin can change any role
            if (currentUser.role === 'admin') {
                return true;
            }
            
            // Users can't change any roles
            if (currentUser.role === 'user') {
                return false;
            }
            
            // Editors cannot change roles at all
            if (currentUser.role === 'editor') {
                return false;
            }
            
            return false;
        };
        
        // Function to update user interface based on role
        async function updateUserInterface() {
            console.log('=== UPDATE USER INTERFACE CALLED ===');
            
            try {
                // Get current user from Supabase
                const { data: { user: authUser }, error: authError } = await supabase.auth.getUser();
                if (authError || !authUser) {
                    console.log('No authenticated user found, redirecting to auth page');
                    window.location.href = 'auth.html';
                    return;
                }
                
                // Get full user profile from database (profiles table)
                const { data: user, error: profileError } = await supabase
                    .from('profiles')
                    .select('*')
                    .eq('id', authUser.id)
                    .single();
                
                if (profileError || !user) {
                    console.log('User profile not found in database, redirecting to auth page');
                    window.location.href = 'auth.html';
                    return;
                }
                
                console.log('User from database:', user);
                console.log('User permissions:', user.permissions);
                console.log('User sections:', user.permissions?.sections);
                
                // Update user info in header
                const userNameEl = document.getElementById('userName');
                const userRoleEl = document.getElementById('userRole');
                
                if (userNameEl) userNameEl.textContent = user.username;
                if (userRoleEl) userRoleEl.textContent = user.role;
                try { if (typeof ensureHeaderVisible === 'function') ensureHeaderVisible(); } catch(_) {}
                
                // Show/hide admin panel button and quick access
                const adminBtn = document.getElementById('adminPanelBtn');
                const adminQuickAccess = document.getElementById('adminQuickAccess');
                const reshuffleBtn = document.getElementById('reshuffleBackgroundsBtn');
                
                console.log('Admin button found:', !!adminBtn);
                console.log('User role:', user.role);
                
                if (String(user.role||'').toLowerCase() === 'admin' || String(user.role||'').toLowerCase() === 'editor' || (user.permissions && user.permissions.canManageUsers)) {
                    // Show admin panel button for admins and managers
                    if (adminBtn) {
                        adminBtn.style.display = 'inline-flex';
                        if (String(user.role||'').toLowerCase() === 'admin') {
                            adminBtn.style.background = '#4CAF50';
                        } else {
                            adminBtn.style.background = '#ff9800'; // Orange for editors
                        }
                        console.log('Admin button should now be visible for', user.role);
                    }
                    
                    // Show admin quick access only for admins
                    if (adminQuickAccess) {
                        if (String(user.role||'').toLowerCase() === 'admin') {
                            adminQuickAccess.style.display = 'block';
                            console.log('Admin quick access shown for admin');
                        } else {
                            adminQuickAccess.style.display = 'none';
                            console.log('Admin quick access hidden for editor');
                        }
                    }
                    

                    // Show reshuffle backgrounds only for admin
                    if (reshuffleBtn) {
                        reshuffleBtn.style.display = (user.role === 'admin') ? 'inline-flex' : 'none';
                    }

                    // Role-based visibility of Assignments and Manage Sections tabs
                    const assignmentsNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('assignments')\"]");
                    const assignmentsContent = document.getElementById('assignments-tab');
                    const manageSectionsNavTab = document.querySelector(".admin-tab[onclick=\"switchAdminTab('sections')\"]");
                    const manageSectionsContent = document.getElementById('sections-tab');
                    if (String(user.role||'').toLowerCase() === 'editor') {
                        // Editors: hide Assignments, allow Manage Sections if permitted
                        if (assignmentsNavTab) assignmentsNavTab.style.display = 'none';
                        if (assignmentsContent) assignmentsContent.style.display = 'none';
                        if (manageSectionsNavTab) manageSectionsNavTab.style.display = '';
                        if (manageSectionsContent) manageSectionsContent.style.display = '';
                    } else {
                        if (assignmentsNavTab) assignmentsNavTab.style.display = '';
                        if (assignmentsContent) assignmentsContent.style.display = '';
                        if (manageSectionsNavTab) manageSectionsNavTab.style.display = '';
                        if (manageSectionsContent) manageSectionsContent.style.display = '';
                    }
                } else {
                    // Hide admin controls for regular users
                    if (adminBtn) adminBtn.style.display = 'none';
                    if (adminQuickAccess) adminQuickAccess.style.display = 'none';
                    if (reshuffleBtn) reshuffleBtn.style.display = 'none';
                    console.log('Admin controls hidden for regular user');
                }
                
                // FORCE UPDATE HUB CARDS WITH FRESH DATA
                console.log('=== FORCING HUB CARDS UPDATE ===');
                await updateHubCardsAccess(user);
                
            } catch (error) {
                console.error('Error updating user interface:', error);
            }
        }
        
        // Function to update hub cards based on user permissions
        async function updateHubCardsAccess(user) {
            console.log('=== UPDATING HUB CARDS ACCESS ===');
            console.log('User object:', user);
            console.log('User permissions:', user.permissions);
            console.log('User sections:', user.permissions?.sections);
            
            // Determine visible sections from database
            let visibleSections = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    const sections = await hubDatabase.getAllSections();
                    visibleSections = sections.filter(s => s.config?.visible !== false).map(s => s.section_id);
                    console.log('Loaded visible sections from database:', visibleSections);
                } else {
                    console.error('Database not ready');
                    return;
                }
            } catch (e) { 
                console.warn('Error reading visible sections', e);
                // Fallback to default sections
                visibleSections = ['costing', 'supply-planning', 'operations', 'quality', 'hr', 'it', 'sales', 'compliance'];
            }
            if (visibleSections.length === 0) {
                visibleSections = ['costing', 'supply-planning', 'operations', 'quality', 'hr', 'it', 'sales', 'compliance'];
            }

            // Get allowed sections (admins see all visible; others intersect with visible)
            let allowedSections = [];
                if (user.role === 'admin') {
                allowedSections = visibleSections;
                console.log('✅ Admin sees all visible sections:', allowedSections);
            } else if (user.permissions && Array.isArray(user.permissions.sections) && user.permissions.sections.length > 0) {
                allowedSections = user.permissions.sections.filter(id => visibleSections.includes(id));
                console.log('✅ Using user-specific section permissions (intersect visible):', allowedSections);
            } else {
                // No specific permissions - show no sections
                allowedSections = [];
                console.log('No specific permissions - showing no sections');
            }
            
            console.log('Final allowed sections for', user.username, ':', allowedSections);
            
            const hubCards = document.querySelectorAll('.hub-card');
            console.log('Found', hubCards.length, 'hub cards');
            
            hubCards.forEach(card => {
                try {
                    const sectionId = card.onclick.toString().match(/navigateToSection\('([^']+)'\)/)[1];
                    console.log('Processing card for section:', sectionId);
                    
                    if (!allowedSections.includes(sectionId)) {
                        card.style.display = 'none'; // Hide sections user can't access
                        console.log('❌ Hiding section:', sectionId, 'for user:', user.username);
                    } else {
                        card.style.display = 'block'; // Show sections user can access
                        console.log('✅ Showing section:', sectionId, 'for user:', user.username);
                    }
                } catch (error) {
                    console.error('Error processing card:', error);
                }
            });
            
            console.log('=== HUB CARDS UPDATE COMPLETE ===');
        }
        
        // Permission Management Functions
        let currentEditingUser = null;
        
        window.refreshUserList = function() {
            loadUsersList();
            loadPermissionUserList();
        };
        
        window.loadPermissionUserList = async function() {
            const select = document.getElementById('permissionUserSelect');
            select.innerHTML = '<option value="">Choose a user...</option>';
            
            // Check if user is authenticated
            const { data: { user: currentUser }, error } = await supabase.auth.getUser();
            if (error || !currentUser) return;
            
            // Load users from Supabase
            let users = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    users = await hubDatabase.getAllUsers();
                    console.log('Loaded users for permission list from Supabase:', users);
                } else {
                    console.log('Database not ready for permission user list');
                    return;
                }
            } catch (error) {
                console.error('Error loading users for permission list:', error);
                return;
            }
            
            if (!currentUser) {
                console.log('No current user session found');
                return;
            }
            
            // Filter users based on current user's role
            const manageableUsers = users.filter(user => {
                return canManageUser(currentUser, user);
            });
            
            console.log('Current user role:', currentUser.role);
            console.log('Manageable users for', currentUser.role, ':', manageableUsers.map(u => `${u.username} (${u.role})`));
            
            manageableUsers.forEach(user => {
                const option = document.createElement('option');
                option.value = user.id;
                option.textContent = `${user.username} (${user.role})`;
                select.appendChild(option);
            });
        };
        window.loadUserPermissions = async function() {
            const userId = document.getElementById('permissionUserSelect').value;
            if (!userId) {
                document.getElementById('userPermissionForm').style.display = 'none';
                return;
            }
            
            // Load the selected user's latest profile directly from Supabase for freshest permissions
            let selectedProfile = null;
            try {
                if (window.supabaseClient) {
                    const { data, error } = await window.supabaseClient
                        .from('profiles')
                        .select('id, username, role, permissions')
                        .eq('id', userId)
                        .single();
                    if (error) { throw error; }
                    selectedProfile = data || null;
                }
            } catch (e) {
                console.warn('Direct profile fetch failed, falling back to cached list', e);
                // Fallback: use hubDatabase list if available
                try {
                    if (window.hubDatabase && window.hubDatabaseReady) {
                        const users = await hubDatabase.getAllUsers();
                        selectedProfile = users.find(u => String(u.id) === String(userId)) || null;
                    }
                } catch(_) {}
            }

            if (!selectedProfile) {
                console.log('Selected profile not found');
                document.getElementById('userPermissionForm').style.display = 'none';
                return;
            }

            // Normalize role and permissions for safety
            const role = (selectedProfile.role || 'user').toLowerCase();
            const perm = selectedProfile.permissions && typeof selectedProfile.permissions === 'object' ? selectedProfile.permissions : {};
            const userSections = Array.isArray(perm.sections) ? perm.sections : [];
            const userEditable = Array.isArray(perm.editableSections) ? perm.editableSections : [];

            currentEditingUser = { ...selectedProfile, role, permissions: { ...perm, sections: userSections, editableSections: userEditable } };
            document.getElementById('selectedUserName').textContent = `${selectedProfile.username || selectedProfile.email || selectedProfile.id} (${role}) Permissions`;
            document.getElementById('userPermissionForm').style.display = 'block';
            
            // Load all available sections; filtering will be applied in the renderer
		const sections = await getAllAvailableSections();
		const sectionNames = await getSectionDisplayNames();
            
            // Update the permission form HTML to include all available sections
            await updatePermissionFormHTML(sections, sectionNames);
            
            sections.forEach(section => {
                const sectionCheckbox = document.getElementById(`section-${section}`);
                const editCheckbox = document.getElementById(`edit-${section}`);
                
                if (sectionCheckbox) {
                    sectionCheckbox.checked = userSections.includes(section);
                }
                if (editCheckbox) {
                    editCheckbox.checked = userEditable.includes(section);
                }
            });
        };

        // Populate Permissions tab user dropdown (Supabase fallback included)
        window.loadPermissionUserList = async function() {
            const select = document.getElementById('permissionUserSelect');
            if (!select) return;
            select.innerHTML = '<option value="">Select a user</option>';
            let users = [];
            try {
                if (window.supabaseClient) {
                    const { data } = await window.supabaseClient
                        .from('profiles')
                        .select('id, username, role, email, permissions')
                        .order('created_at', { ascending: false });
                    users = Array.isArray(data) ? data : [];
                } else if (window.hubDatabase && window.hubDatabaseReady) {
                    users = await hubDatabase.getAllUsers();
                }
            } catch (e) { console.error('loadPermissionUserList error:', e); }

            // Filter by manageability if helper and session exist
            let currentUser = null;
            try {
                if (window.supabaseClient) {
                    const { data: { user: me } } = await window.supabaseClient.auth.getUser();
                    if (me) {
                        const { data: profile } = await window.supabaseClient.from('profiles').select('id, role, username, permissions').eq('id', me.id).single();
                        currentUser = profile || null;
                    }
                }
            } catch(_) {}
            if (currentUser && typeof canManageUser === 'function') {
                try {
                    const manageable = users.filter(u => canManageUser(currentUser, u));
                    if (manageable.length > 0) users = manageable; // only apply if not empty
                } catch(_) {}
            }

            if (!Array.isArray(users) || users.length === 0) {
                select.innerHTML += '<option disabled>(no users)</option>';
                return;
            }

            users.forEach(u => {
                const opt = document.createElement('option');
                opt.value = u.id;
                opt.textContent = `${u.username || u.email || u.id} (${String(u.role || 'user').toUpperCase()})`;
                select.appendChild(opt);
            });

            // Auto-load permissions for the first selectable user
            try {
                if (!select.value && users[0] && users[0].id) select.value = String(users[0].id);
                if (select.value) await loadUserPermissions();
            } catch(_) {}
        };
        
        window.updateSectionPermission = function(section) {
            const editCheckbox = document.getElementById(`edit-${section}`);
            const sectionCheckbox = document.getElementById(`section-${section}`);
            
            // If section access is removed, also remove edit permission
            if (!sectionCheckbox.checked && editCheckbox) {
                editCheckbox.checked = false;
            }
        };
        
        window.updateEditPermission = function(section) {
            const editCheckbox = document.getElementById(`edit-${section}`);
            const sectionCheckbox = document.getElementById(`section-${section}`);
            
            // If edit permission is given, also give section access
            if (editCheckbox.checked && sectionCheckbox) {
                sectionCheckbox.checked = true;
            }
        };

		// Bulk toggles for permissions tab
		window.toggleAllAccess = function(value) {
			try {
				const container = document.getElementById('editUserSectionCheckboxes') || document.getElementById('sectionCheckboxes');
				if (!container) return;
				// Support both admin permissions panel (section-*) and edit modal (editSection-*)
				const accessInputs = container.querySelectorAll('input[id^="section-"], input[id^="editSection-"]');
				accessInputs.forEach(inp => {
					inp.checked = !!value;
					if (!value) {
						const id = String(inp.id || '');
						const section = id.startsWith('editSection-') ? id.replace('editSection-', '') : id.replace('section-', '');
						const edit = document.getElementById(`edit-${section}`);
						if (edit) edit.checked = false;
					}
				});
				// Re-render chips in edit modal if present
				try { if (typeof renderEditChips === 'function') renderEditChips(); } catch(_) {}
			} catch(_) {}
		};
		window.toggleAllEdit = function(value) {
			try {
				const container = document.getElementById('editUserSectionCheckboxes') || document.getElementById('sectionCheckboxes');
				if (!container) return;
				const inputs = container.querySelectorAll('input[id^="edit-"], input[id^="editSection-"]');
				inputs.forEach(inp => {
					inp.checked = !!value;
					if (value) {
						const id = String(inp.id || '');
						const section = id.startsWith('editSection-') ? id.replace('editSection-', '') : id.replace('edit-', '');
						const access = document.getElementById(`section-${section}`) || document.getElementById(`editSection-${section}`);
						if (access) access.checked = true;
					}
				});
				// Re-render chips in edit modal if present
				try { if (typeof renderEditChips === 'function') renderEditChips(); } catch(_) {}
			} catch(_) {}
		};
		window.saveUserPermissions = async function() {
			if (!currentEditingUser) return;
			
			// Save against all sections shown in the form (not role-filtered)
			const sections = await getAllAvailableSections();
			const newSections = [];
			const newEditableSections = [];
			
			sections.forEach(section => {
				const sectionCheckbox = document.getElementById(`section-${section}`);
				const editCheckbox = document.getElementById(`edit-${section}`);
				if (sectionCheckbox && sectionCheckbox.checked) newSections.push(section);
				if (editCheckbox && editCheckbox.checked) newEditableSections.push(section);
			});

			// Build next permissions payload based on currentEditingUser
			const existingPerm = currentEditingUser.permissions && typeof currentEditingUser.permissions === 'object' ? currentEditingUser.permissions : {};
			const nextPermissions = { ...existingPerm, sections: newSections, editableSections: newEditableSections };
            
            // Debug: log exact payload and target id
            try {
                console.log('DEBUG saveUserPermissions → target', { userId: currentEditingUser.id, role: currentEditingUser.role });
                console.log('DEBUG saveUserPermissions → payload', nextPermissions);
            } catch(_) {}

			// Update only the permissions column directly via Supabase to avoid payload mismatches
			try {
				if (!window.supabaseClient) throw new Error('Supabase not initialized');
				const { data: updated, error } = await window.supabaseClient
					.from('profiles')
					.update({ permissions: nextPermissions })
					.eq('id', currentEditingUser.id)
					.select('id')
					.maybeSingle();
				if (error) throw error;
				try { console.log('DEBUG saveUserPermissions → updated row', updated); } catch(_) {}
				if (!updated) throw new Error('No row updated. Likely blocked by RLS or ID mismatch.');
			} catch (error) {
				console.error('Error updating user permissions in Supabase:', error);
				const detail = (error && (error.message || error.details || error.code)) ? (' ' + (error.message || error.details || error.code)) : '';
				alert('Failed to save permissions:' + detail + (currentEditingUser?.id ? (' (userId=' + currentEditingUser.id + ')') : ''));
				return;
			}
			
			// Reflect changes in memory
			try {
				currentEditingUser = { ...currentEditingUser, permissions: nextPermissions };
			} catch(_) {}
			
			// If editing the currently logged-in user, refresh the header/permissions from Supabase
			try { if (typeof updateUserInterface === 'function') updateUserInterface(); } catch(_) {}
				
			alert('User permissions updated successfully!');
			loadUsersList();
		};
        window.resetUserPermissions = function() {
            if (currentEditingUser) {
                loadUserPermissions();
            }
        };
        
        // Admin Panel Functions
        window.loadUsersList = async function() {
            const usersList = document.getElementById('usersList');
            if (!usersList) return;
            
            // Check if user is authenticated
            const { data: { user }, error } = await (window.supabaseClient ? window.supabaseClient.auth.getUser() : { data: { user: null }, error: new Error('No client') });
            if (error || !user) { 
                usersList.innerHTML = '<div class="empty">Please log in.</div>'; 
                return; 
            }
            
            // Load users from Supabase only
            let users = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    users = await hubDatabase.getAllUsers();
                    console.log('Loaded users from Supabase:', users);
                } else {
                    console.log('Database not ready, showing empty list');
                    usersList.innerHTML = '<div class="empty">Database not ready. Please try again.</div>';
                    return;
                }
            } catch (error) {
                console.error('Error loading users from Supabase:', error);
                usersList.innerHTML = '<div class="empty">Error loading users. Please try again.</div>';
                return;
            }
            
            // Normalize permissions
            const defaults = {
                admin: { canManageUsers: true, canEditAllSections: true, canDeleteResources: true, canViewAuditLog: true, canManageRoles: true, sections: ['costing','supply-planning','operations','quality','hr','it','sales','compliance'], editableSections: ['costing','supply-planning','operations','quality','hr','it','sales','compliance'] },
                editor: { canManageUsers: false, canEditAllSections: false, canDeleteResources: true, canViewAuditLog: false, canManageRoles: false, sections: ['costing','supply-planning','operations','quality'], editableSections: ['costing','supply-planning','operations','quality'] },
                viewer: { canManageUsers: false, canEditAllSections: false, canDeleteResources: false, canViewAuditLog: false, canManageRoles: false, sections: ['costing','supply-planning'], editableSections: [] }
            };
            users = users.map(u => ({
                ...u,
                role: (typeof u.role === 'string' ? u.role : u.role),
                permissions: u.permissions ? { sections: u.permissions.sections || [], editableSections: u.permissions.editableSections || [] , ...u.permissions } : u.permissions
            }));
            
            // Text filter
            const term = (document.getElementById('userSearchInput')?.value || '').trim().toLowerCase();
            if (term) {
                users = users.filter(u =>
                    (u.username || '').toLowerCase().includes(term) ||
                    (u.name || '').toLowerCase().includes(term) ||
                    (u.email || '').toLowerCase().includes(term) ||
                    (u.role || '').toLowerCase().includes(term)
                );
            }

            // Filter by role hierarchy (admins see all)
            const manageableUsers = users.filter(u => canManageUser(currentUser, u));
            
            if (manageableUsers.length === 0) {
                usersList.innerHTML = '<div class="empty">No users found.</div>';
                return;
            }
            
            usersList.innerHTML = manageableUsers.map(user => `
                <div class="user-item">
                    <div class="user-details-info">
                        <div class="name">${user.username || user.email}</div>
                        <div class="role">${(user.role || '').toUpperCase()}</div>
                        <div class="sections">Access: ${user.permissions.sections.length} · Edit: ${user.permissions.editableSections.length}</div>
                    </div>
                    <div class="user-item-actions">
                        <button class="btn btn-secondary" onclick="editUser(${user.id})" title="Edit">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="btn btn-danger" onclick="deleteUser(${user.id})" title="Delete">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `).join('');
        };
        
        window.loadAuditLog = function() {
            try {
                if (window.informationHub && typeof window.informationHub.loadAuditLog === 'function') {
                    return window.informationHub.loadAuditLog();
                }
                // Fallback: initialize and retry once
                if (typeof initInformationHubOnce === 'function') {
                    initInformationHubOnce();
                    setTimeout(() => { try { if (window.informationHub) window.informationHub.loadAuditLog(); } catch(_) {} }, 300);
                }
            } catch (_) {}
        };
        
        window.editUser = async function(userId) {
            console.log('Editing user:', userId);
            
            // Get current user session
            const session = localStorage.getItem('hubSession');
            const currentUser = session ? JSON.parse(session) : null;
            
            if (!currentUser) {
                alert('Please log in to edit users');
                return;
            }
            
            // Load users from Supabase
            let users = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    users = await hubDatabase.getAllUsers();
                    console.log('Loaded users for editing from Supabase:', users);
                } else {
                    alert('Database not ready. Please try again.');
                    return;
                }
            } catch (error) {
                console.error('Error loading users for editing:', error);
                alert('Failed to load users: ' + error.message);
                return;
            }
            
            const user = users.find(u => u.id === userId);
            
            if (!user) {
                alert('User not found');
                return;
            }
            
            // Check if current user can manage this user
            if (!canManageUser(currentUser, user)) {
                alert('You do not have permission to manage this user');
                return;
            }
            
            // Show edit user modal
            showEditUserModal(user);
        };
        
        // Show edit user modal
        window.showEditUserModal = async function(user) {
            // Resolve current user's role via Supabase first, fallback to hub state
            let currentRole = 'viewer';
            try {
                if (window.supabaseClient && typeof window.supabaseClient.auth.getUser === 'function') {
                    const { data: { user: me } } = await window.supabaseClient.auth.getUser();
                    if (me && me.id) {
                        const { data: prof } = await window.supabaseClient
                            .from('profiles')
                            .select('role')
                            .eq('id', me.id)
                            .single();
                        if (prof && prof.role) currentRole = String(prof.role).toLowerCase();
                    }
                }
            } catch (_) {}
            if (!currentRole || currentRole === 'viewer') {
                try { currentRole = String(window.informationHub?.currentUser?.role || '').toLowerCase() || currentRole; } catch(_) {}
            }
            if (!currentRole || currentRole === 'viewer') {
                try { const sess = JSON.parse(localStorage.getItem('hubSession') || 'null'); if (sess && sess.role) currentRole = String(sess.role).toLowerCase(); } catch(_) {}
            }

            // Determine role options based on current role
            let roleOptions = '';
            if (currentRole === 'admin') {
                roleOptions = `
                    <option value="admin" ${user.role === 'admin' ? 'selected' : ''}>Admin</option>
                    <option value="editor" ${user.role === 'editor' ? 'selected' : ''}>Editor</option>
                    <option value="viewer" ${user.role === 'viewer' ? 'selected' : ''}>Viewer</option>
                `;
            } else {
                roleOptions = `
                    <option value="${user.role}" selected>${user.role.charAt(0).toUpperCase() + user.role.slice(1)}</option>
                `;
            }
            
            // Create modal HTML
            const modalHTML = `
                <div id="editUserModal" class="modal" style="display: block;">
                    <div class="modal-content edit-user-modal">
                        <div class="modal-header">
                            <h2 style="display:flex;align-items:center;gap:10px;">
                                Edit User
                                <span class="role-badge" style="font-size:12px;padding:4px 8px;border-radius:999px;background:#eef2ff;color:#3f51b5;border:1px solid #dce1ff;">${(user.role||'user').toUpperCase()}</span>
                                <span style="font-size:12px;color:#666;">${user.email || ''}</span>
                            </h2>
                            <span class="close" onclick="closeModal('editUserModal')">&times;</span>
                        </div>
                        <div class="modal-body edit-user-body" style="display:grid;grid-template-columns:1fr 1fr;gap:16px;align-items:flex-start;">
                            <div class="user-basic-info" style="display:flex;flex-direction:column;gap:10px;">
                                <div class="form-group">
                                    <label for="editUserName">Username</label>
                                    <input type="text" id="editUserName" value="${user.username}" readonly>
                                </div>
                                <div class="form-group">
                                    <label for="editUserFullName">Full Name</label>
                                    <input type="text" id="editUserFullName" value="${user.name || ''}">
                                </div>
                                <div class="form-group">
                                    <label for="editUserEmail">Email</label>
                                    <input type="email" id="editUserEmail" value="${user.email || ''}">
                                </div>
                                <div class="form-group">
                                    <label for="editUserRole">Role</label>
                                    <select id="editUserRole" ${currentRole === 'admin' ? '' : 'disabled'}>
                                        ${roleOptions}
                                    </select>
                                    ${currentRole === 'admin' ? '' : '<small style="color: #666;">Only admins can change roles</small>'}
                                </div>
                                <div class="form-group" style="display:flex;align-items:center;gap:8px;">
                                    <input type="checkbox" id="editUserDisabled" ${(user.permissions && user.permissions.disabled) ? 'checked' : ''}>
                                    <label for="editUserDisabled">Deactivated (prevent login)</label>
                                </div>
                                <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:4px;">
                                    <button class="btn btn-secondary" type="button" onclick="sendPasswordReset('${user.email || ''}')"><i class="fas fa-envelope"></i> Send Password Reset</button>
                                    <button class="btn btn-secondary" type="button" onclick="document.getElementById('editUserDisabled').checked = !document.getElementById('editUserDisabled').checked"><i class="fas fa-user-slash"></i> Toggle Deactivate</button>
                                </div>
                            </div>
                            <div class="section-permissions-container" style="display:flex;flex-direction:column;gap:10px;">
                                <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
                                    <h3 style="margin:0;">Section Permissions</h3>
                                    <div style="display:flex;gap:8px;flex-wrap:wrap;">
                                        <button class="btn btn-sm btn-secondary" type="button" onclick="toggleAllAccess(true)">Access: All</button>
                                        <button class="btn btn-sm btn-secondary" type="button" onclick="toggleAllAccess(false)">Access: None</button>
                                        <button class="btn btn-sm btn-secondary" type="button" onclick="toggleAllEdit(true)">Edit: All</button>
                                        <button class="btn btn-sm btn-secondary" type="button" onclick="toggleAllEdit(false)">Edit: None</button>
                                    </div>
                                </div>
                                <div id="selectedSectionChips" style="display:flex;gap:6px;flex-wrap:wrap;"></div>
                                <div class="section-checkboxes" id="editUserSectionCheckboxes">
                                    <!-- Sections will be loaded here -->
                                </div>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button class="btn btn-primary" onclick="saveUserChanges('${user.id}')">Save Changes</button>
                            <button class="btn btn-secondary" onclick="closeModal('editUserModal')">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            
            // Add modal to page
            document.body.insertAdjacentHTML('beforeend', modalHTML);
            try {
                const m = document.getElementById('editUserModal');
                if (m) {
                    m.style.display = 'block';
                    m.style.zIndex = '10005';
                    const content = m.querySelector('.modal-content');
                    if (content) content.style.zIndex = '10006';
                }
            } catch(_) {}
			// Load sections for the modal (show all sections from DB, not role-filtered)
			try {
				const sections = await getAllAvailableSections();
				const sectionNames = await getSectionDisplayNames();
                const sectionCheckboxes = document.getElementById('editUserSectionCheckboxes');
                
                if (sectionCheckboxes) {
                    sectionCheckboxes.innerHTML = sections.map(section => {
                        const hasAccess = user.permissions && user.permissions.sections && user.permissions.sections.includes(section);
                        return `
                            <label class=\"section-checkbox\">
                                <input type=\"checkbox\" 
                                       value=\"${section}\" 
                                       ${hasAccess ? 'checked' : ''}
                                       id=\"editSection-${section}\">
                                <span>${sectionNames[section] || section}</span>
                            </label>
                        `;
                    }).join('');
                    // Render chips for selected
                    const chipBox = document.getElementById('selectedSectionChips');
                    if (chipBox) {
                        const renderChips = () => {
                            const nowSelected = sections.filter(x => document.getElementById(`editSection-${x}`)?.checked);
                            chipBox.innerHTML = nowSelected.map(x => `<span style=\"display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border:1px solid #ddd;border-radius:999px;background:#fff;\">${sectionNames[x]||x}<button type=\"button\" onclick=\"(function(){const cb=document.getElementById('editSection-${x}');if(cb){cb.checked=false;}document.querySelector('#editUserModal .btn.btn-primary').scrollIntoView({behavior:'smooth',block:'nearest'});})()\" style=\"border:none;background:transparent;color:#888;cursor:pointer\">×</button></span>`).join('');
                        };
                        renderChips();
                        sections.forEach(s => {
                            const cb = document.getElementById(`editSection-${s}`);
                            if (cb) cb.addEventListener('change', renderChips);
                        });
                    }
                }
            } catch (error) {
                console.error('Error loading sections for edit modal:', error);
            }
        };
        
        // Save user changes
        window.saveUserChanges = async function(userId) {
            console.log('Saving changes for user:', userId);
            
            // Get current user session (fallback to Supabase auth if missing)
            let currentUser = null;
            try {
                const currentSession = localStorage.getItem('hubSession');
                currentUser = currentSession ? JSON.parse(currentSession) : null;
            } catch(_) { currentUser = null; }
            if (!currentUser) {
                try {
                    if (window.supabaseClient && typeof window.supabaseClient.auth?.getUser === 'function') {
                        const { data: { user: authUser } } = await window.supabaseClient.auth.getUser();
                        if (authUser && authUser.id) {
                            try {
                                const { data: prof } = await window.supabaseClient
                                    .from('profiles')
                                    .select('id, username, role, permissions')
                                    .eq('id', authUser.id)
                                    .single();
                                if (prof) {
                                    currentUser = {
                                        id: prof.id,
                                        username: prof.username,
                                        role: prof.role || 'viewer',
                                        permissions: prof.permissions || {}
                                    };
                                }
                            } catch(_) {}
                        }
                    }
                } catch(_) { currentUser = null; }
            }
            if (!currentUser) { alert('Please log in to save changes'); return; }
            
            // Get form values
            const fullName = document.getElementById('editUserFullName').value;
            const email = document.getElementById('editUserEmail').value;
            const roleSelect = document.getElementById('editUserRole');
            const role = roleSelect.value;
			// Collect selected permissions from the modal by reading existing checkboxes in the DOM
			// This avoids waiting on any network call that could cause a pending state
			const selectedSections = [];
            const selectedEditableSections = [];
            try {
                document.querySelectorAll('#editUserModal input[id^="editSection-"]').forEach(cb => {
                    if (cb && cb.checked) {
                        const section = cb.id.replace('editSection-','');
                        if (section) selectedSections.push(section);
                    }
                });
                document.querySelectorAll('#editUserModal input[id^="edit-"]').forEach(cb => {
                    if (cb && cb.checked) {
                        const section = cb.id.replace('edit-','');
                        if (section) selectedEditableSections.push(section);
                    }
                });
            } catch(_) {}

            // Put Save button into loading state
            let saveBtn = null;
            try { saveBtn = document.querySelector('#editUserModal .btn.btn-primary'); if (saveBtn) { saveBtn.disabled = true; saveBtn.dataset._oldText = saveBtn.textContent; saveBtn.textContent = 'Saving…'; } } catch(_) {}
            
            // Load users from Supabase
            let users = [];
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    users = await hubDatabase.getAllUsers();
                    console.log('Loaded users for editing from Supabase:', users);
                } else {
                    alert('Database not ready. Please try again.');
                    return;
                }
            } catch (error) {
                console.error('Error loading users for editing:', error);
                alert('Failed to load users: ' + error.message);
                return;
            }
            
            let userIndex = users.findIndex(u => String(u && u.id) === String(userId));
            if (userIndex === -1) {
                try {
                    if (window.supabaseClient) {
                        const { data: prof, error: fetchErr } = await window.supabaseClient
                            .from('profiles')
                            .select('id, username, name, email, role, permissions')
                            .eq('id', userId)
                            .single();
                        if (!fetchErr && prof && prof.id) {
                            users.push(prof);
                            userIndex = users.length - 1;
                        }
                    }
                } catch(_) {}
            }
            if (userIndex === -1) { alert('User not found'); return; }
            
            const targetUser = users[userIndex];
            
            // Check if role change is allowed
            if (targetUser.role !== role && !canChangeUserRole(currentUser, targetUser, role)) {
                alert('You do not have permission to change this user\'s role');
                return;
            }
            
            // Update user data
            users[userIndex].name = fullName;
            users[userIndex].email = email;
            users[userIndex].role = role;
            users[userIndex].updatedAt = new Date().toISOString();
            // Deactivate flag
            try {
                const deact = document.getElementById('editUserDisabled');
                if (deact) {
                    users[userIndex].permissions = users[userIndex].permissions || {};
                    users[userIndex].permissions.disabled = !!deact.checked;
                }
            } catch(_) {}
            
            // Update permissions
            if (!users[userIndex].permissions) {
                users[userIndex].permissions = {};
            }
            const roleChanged = (typeof targetUser.role === 'string' && typeof role === 'string') ? (String(targetUser.role).toLowerCase() !== String(role).toLowerCase()) : false;
            if (roleChanged) {
                const defaults = {
                    admin: { canManageUsers: true, canEditAllSections: true, canDeleteResources: true, canViewAuditLog: true, canManageRoles: true, sections: ['costing','supply-planning','operations','quality','hr','it','sales','compliance'], editableSections: ['costing','supply-planning','operations','quality','hr','it','sales','compliance'] },
                    editor: { canManageUsers: false, canEditAllSections: false, canDeleteResources: true, canViewAuditLog: false, canManageRoles: false, sections: ['costing','supply-planning','operations','quality'], editableSections: ['costing','supply-planning','operations','quality'] },
                    viewer: { canManageUsers: false, canEditAllSections: false, canDeleteResources: false, canViewAuditLog: false, canManageRoles: false, sections: ['costing','supply-planning'], editableSections: [] }
                };
                // Map any legacy roles if present
                // Keep existing permissions if present; do not coerce by role
                users[userIndex].permissions = users[userIndex].permissions || {};
            }
            users[userIndex].permissions = users[userIndex].permissions || {};
            users[userIndex].permissions.sections = selectedSections;
            users[userIndex].permissions.editableSections = selectedEditableSections;
            
            // Save updated user to Supabase (with timeout guard)
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    try {
                        const updatePromise = hubDatabase.updateUser(users[userIndex]);
                        const withTimeout = Promise.race([
                            updatePromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('Request timeout while updating user')), 15000))
                        ]);
                        await withTimeout;
                        console.log('User updated in Supabase (wrapper):', users[userIndex]);
                    } catch (wrapperErr) {
                        console.warn('Wrapper update failed, trying direct profile update', wrapperErr);
                        if (!window.supabaseClient) throw wrapperErr;
                        const directPromise = window.supabaseClient
                            .from('profiles')
                            .update((() => { const payload = { username: users[userIndex].username, name: users[userIndex].name, email: users[userIndex].email, permissions: users[userIndex].permissions }; if (typeof users[userIndex].role === 'string') payload.role = users[userIndex].role; return payload; })())
                            .eq('id', userId);
                        const { error: upErr } = await Promise.race([
                            directPromise,
                            new Promise((_, rej) => setTimeout(() => rej(new Error('Request timeout while updating user (direct)')), 15000))
                        ]);
                        if (upErr) throw upErr;
                        console.log('User updated via direct Supabase');
                    }
                    
                    // Update local storage for consistency
                    // Save to Supabase database - users are automatically saved when modified
            } else {
                    alert('Database not ready. Please try again.');
                return;
            }
            } catch (error) {
                console.error('Error updating user in Supabase:', error);
                alert('Failed to save user: ' + (error && error.message ? error.message : error));
                return;
            } finally {
                try { if (saveBtn) { saveBtn.disabled = false; if (saveBtn.dataset._oldText) saveBtn.textContent = saveBtn.dataset._oldText; } } catch(_) {}
            }
            console.log('User updated in localStorage:', users[userIndex]);
            
            // Update current session if it's the same user
            const updatedSession = localStorage.getItem('hubSession');
            if (updatedSession) {
                const sessionData = JSON.parse(updatedSession);
                if (sessionData.userId === userId) {
                    sessionData.permissions = users[userIndex].permissions;
                    sessionData.name = users[userIndex].name;
                    sessionData.email = users[userIndex].email;
                    sessionData.role = users[userIndex].role;
                    localStorage.setItem('hubSession', JSON.stringify(sessionData));
                    console.log('Updated current session:', sessionData);
                    
                    // Update UI for current user
                    updateUserInterface();
                }
            }
            
            // Close modal
            closeModal('editUserModal');
            
            // Refresh user list
            loadUsersList();
            
            // Show success message
            try { informationHub.showMessage('User updated successfully', 'success'); } catch(_) { alert('User updated successfully!'); }
            
            console.log('User updated:', users[userIndex]);
        };
        
        window.deleteUser = async function(userId) {
            // Get current user session
            const session = localStorage.getItem('hubSession');
            const currentUser = session ? JSON.parse(session) : null;
            
            if (!currentUser) {
                alert('Please log in to delete users');
                return;
            }
            
            // Get target user
            const users = window.hubDatabase && window.hubDatabaseReady ? await hubDatabase.getAllUsers() : [];
            const targetUser = users.find(u => u.id === userId);
            
            if (!targetUser) {
                alert('User not found');
                return;
            }
            
            // Check if current user can manage this user
            if (!canManageUser(currentUser, targetUser)) {
                alert('You do not have permission to delete this user');
                return;
            }
            
            if (confirm('Are you sure you want to delete this user? This removes their profile (not auth account).')) {
                // Delete user from Supabase database
                if (window.hubDatabase && window.hubDatabaseReady) {
                    try {
                        await hubDatabase.deleteUser(userId);
                    } catch (wrapperErr) {
                        console.warn('Wrapper delete failed, trying direct Supabase delete', wrapperErr);
                        if (!window.supabaseClient) { alert('Supabase not initialized'); return; }
                        const { error: delErr } = await window.supabaseClient
                            .from('profiles')
                            .delete()
                            .eq('id', userId);
                        if (delErr) { alert('Delete failed: ' + delErr.message); return; }
                    }
                } else {
                    alert('Database unavailable – cannot delete.');
                    return;
                }
                // Mirror to local/DB
                const updatedUsers = users.filter(u => u.id !== userId);
                localStorage.setItem('hubUsers', JSON.stringify(updatedUsers));
                try { if (window.hubDatabase && hubDatabase.deleteUser) { await hubDatabase.deleteUser(userId); } } catch(_){ }
                loadUsersList();
                alert('User deleted successfully');
            }
        };
        
        window.switchAdminTab = function(tabName) {
            console.log('Switching to tab:', tabName);
            
            // Update tab appearance
            document.querySelectorAll('.admin-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            try {
                const selectedNav = document.querySelector(`.admin-tab[onclick="switchAdminTab('${tabName}')"]`);
                if (selectedNav) selectedNav.classList.add('active');
            } catch(_) {}

            // Show/hide content sections
            document.querySelectorAll('.admin-tab-content').forEach(content => {
                content.classList.remove('active');
                try { content.style.display = 'none'; } catch(_) {}
            });
            
            const targetTab = document.getElementById(`${tabName}-tab`);
            if (targetTab) {
                targetTab.classList.add('active');
                try { targetTab.style.display = 'block'; } catch(_) {}
                console.log('Tab content activated:', tabName);
            } else {
                console.error('Tab content not found:', `${tabName}-tab`);
            }

            // Load specific tab content
            if (tabName === 'users') {
                try { renderCurrentUserSummary(); } catch (e) { console.warn('renderCurrentUserSummary error', e); }
                loadUsersList();
            } else if (tabName === 'permissions') {
                loadPermissionUserList();
            } else if (tabName === 'audit') {
                loadAuditLog();
            } else if (tabName === 'sections') {
                console.log('Loading sections list...');
                loadSectionsList();
            } else if (tabName === 'assignments') {
                console.log('Loading section assignments...');
                try { const si = document.getElementById('assignmentUserSearchInput'); if (si) si.value = ''; } catch(_) {}
                try {
                    const hasCache = Array.isArray((window.__assignmentsCache||{}).users) && (window.__assignmentsCache.users.length > 0) && Array.isArray(window.__assignmentsCache.sectionIds) && (window.__assignmentsCache.sectionIds.length > 0);
                    if (hasCache && typeof renderAssignmentsList === 'function') { renderAssignmentsList(); setTimeout(() => { try { renderAssignmentsList(); } catch(_) {} }, 0); }
                    else { loadSectionAssignments(); }
                } catch(_) { loadSectionAssignments(); }
            }
        };

        // Toggle compact admin UI
        window.toggleCompactAdmin = function() {
            const modal = document.getElementById('adminPanelModal');
            if (!modal) return;
            const content = modal.querySelector('.modal-content');
            if (!content) return;
            if (document.getElementById('compactToggle')?.checked) {
                content.classList.add('compact-admin');
            } else {
                content.classList.remove('compact-admin');
            }
        };

        // Render current user summary in Users tab
        window.renderCurrentUserSummary = function() {
            const container = document.getElementById('currentUserSummary');
            if (!container) return;
            let user = null;
            try {
                const session = localStorage.getItem('hubSession');
                user = session ? JSON.parse(session) : null;
            } catch (_) {}
            if (!user) { container.innerHTML = ''; return; }
            const roleLabel = (user.role || '').toUpperCase();
            container.innerHTML = `
                <div style="display:flex;align-items:center;gap:12px;margin:10px 0 15px 0;padding:10px 12px;background:#f8f9fa;border:1px solid #e9ecef;border-radius:8px;">
                    <i class="fas fa-user-circle" style="font-size:20px;color:#667eea"></i>
                    <div style="display:flex;gap:8px;align-items:center;flex-wrap;">
                        <strong>Signed in as:</strong>
                        <span>${user.username}</span>
                        <span class="user-role" style="margin-left:8px;">${roleLabel}</span>
                    </div>
                </div>
            `;
        };
        
        window.closeModal = function(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.style.display = 'none';
                // Remove the modal from DOM if it's the edit user modal
                if (modalId === 'editUserModal') {
                    modal.remove();
                }
            }
        };
        
        // Section Management Functions
        let sectionOrder = [];
        
        // NO localStorage sync - use Supabase only
        
        // Function to get all available sections dynamically - Supabase ONLY (no fallbacks)
        async function getAllAvailableSections() {
            try {
                // Determine caller role to decide visibility filtering
                let role = null;
                let canManage = false;
                if (window.supabaseClient) {
                    try {
                        const { data: { user: authUser } } = await window.supabaseClient.auth.getUser();
                        if (authUser) {
                            const { data: profile } = await window.supabaseClient
                                .from('profiles')
                                .select('role, permissions')
                                .eq('id', authUser.id)
                                .single();
                            if (profile) {
                                role = String(profile.role || '').toLowerCase();
                                canManage = !!(profile.permissions && profile.permissions.canManageUsers);
                            }
                        }
                    } catch (_) {}
                }

                const isAdminLike = (role === 'admin' || canManage === true);

                if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getAllSections === 'function') {
                    let sections = await hubDatabase.getAllSections();
                    // Fallback to direct Supabase if wrapper returns empty
                    if ((!sections || sections.length === 0) && window.supabaseClient) {
                        try {
                            const { data } = await window.supabaseClient
                                .from('sections')
                                .select('section_id, config');
                            sections = Array.isArray(data) ? data : [];
                        } catch (_) {}
                    }
                    const ids = (sections || [])
                        .filter(s => isAdminLike ? true : (s && (s.config?.visible !== false)))
                        .map(s => s.section_id || s.id)
                        .filter(Boolean);
                    return ids || [];
                } else if (window.supabaseClient) {
                    const { data } = await window.supabaseClient
                        .from('sections')
                        .select('section_id, config');
                    const list = Array.isArray(data) ? data : [];
                    const ids = list
                        .filter(row => isAdminLike ? true : ((row && row.config && typeof row.config === 'object') ? (row.config.visible !== false) : true))
                        .map(row => row.section_id)
                        .filter(Boolean);
                    return ids || [];
                }
            } catch (error) {
                console.error('Error loading sections from database:', error);
            }
            // Strict fallback: empty when none in DB
            return [];
        }
        // Function to get sections the CURRENT USER can assign - SUPABASE ONLY
        async function getAssignableSectionsForCurrentUser() {
            try {
                const all = await getAllAvailableSections();
                // Prefer live profile from Supabase
                let role = null;
                let permissions = {};
                if (window.supabaseClient) {
                    try {
                        const { data: { user: authUser } } = await window.supabaseClient.auth.getUser();
                        if (authUser) {
                            const { data: profile } = await window.supabaseClient
                                .from('profiles')
                                .select('role, permissions')
                                .eq('id', authUser.id)
                                .single();
                            if (profile) {
                                role = String(profile.role || '').toLowerCase();
                                permissions = (profile.permissions && typeof profile.permissions === 'object') ? profile.permissions : {};
                            }
                        }
                    } catch (_) {}
                }
                // Fallback to local session if needed
                if (!role) {
                    const raw = localStorage.getItem('hubSession');
                    if (raw) {
                        try {
                            const sess = JSON.parse(raw);
                            role = String(sess.role || '').toLowerCase();
                            permissions = sess.permissions || {};
                        } catch (_) {}
                    }
                }
                if (!Array.isArray(all) || all.length === 0) return [];
                // Full access cases
                if (role === 'admin' || permissions.canEditAllSections === true || permissions.canViewAllSections === true) return all;
                // Wildcard access
                if (Array.isArray(permissions.sections) && permissions.sections.includes('*')) return all;
                // Editors/managers: can assign sections they are allowed to edit; fallback to view sections
                const editable = Array.isArray(permissions.editableSections) ? permissions.editableSections : [];
                const viewable = Array.isArray(permissions.sections) ? permissions.sections : [];
                const allowed = (editable.length > 0 ? editable : viewable);
                if (!Array.isArray(allowed) || allowed.length === 0) return [];
                const allowedSet = new Set(allowed);
                return all.filter(s => allowedSet.has(s));
            } catch (e) {
                console.error('getAssignableSectionsForCurrentUser failed', e);
                return [];
            }
        }
        
        // Function to get section display names - Supabase ONLY (no defaults)
        async function getSectionDisplayNames() {
            try {
                if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getAllSections === 'function') {
                    let sections = await hubDatabase.getAllSections();
                    // Fallback to direct Supabase if wrapper returns empty
                    if ((!sections || sections.length === 0) && window.supabaseClient) {
                        try {
                            const { data } = await window.supabaseClient
                                .from('sections')
                                .select('section_id, name')
                                .order('name', { ascending: true });
                            sections = Array.isArray(data) ? data : [];
                        } catch (_) {}
                    }
                    const names = {};
                    (sections || []).forEach(section => {
                        names[section.section_id || section.id] = section.name;
                    });
                    return names;
                }
            } catch (error) {
                console.error('Error loading section names from database:', error);
            }
            // Strict fallback: empty map
            return {};
        }
        
        // Function to refresh permission forms when sections change
        function refreshPermissionForms() {
            // If permission form is open, refresh it
            if (currentEditingUser) {
                loadUserPermissions();
            }
            
            // If admin panel is open, refresh the user list
            const adminModal = document.getElementById('adminPanelModal');
            if (adminModal && adminModal.style.display === 'block') {
                loadUsersList();
            }
        }
        
        // Function to update permission form HTML with dynamic sections (filtered for editors)
        async function updatePermissionFormHTML(sections, sectionNames) {
            console.log('updatePermissionFormHTML called with sections:', sections);
            console.log('updatePermissionFormHTML called with sectionNames:', sectionNames);
            
            const sectionCheckboxes = document.getElementById('sectionCheckboxes');
            console.log('sectionCheckboxes element found:', !!sectionCheckboxes);
            
            if (!sectionCheckboxes) {
                console.error('sectionCheckboxes element not found!');
                return;
            }
		// Editors: only show sections they can manage (their editableSections). Admins: show all.
		let filteredSections = Array.isArray(sections) ? sections.slice() : [];
		try {
			let me = null;
			if (window.supabaseClient) {
				const { data: { user } } = await window.supabaseClient.auth.getUser();
				if (user && user.id) {
					const { data: profile } = await window.supabaseClient
						.from('profiles')
						.select('role, permissions')
						.eq('id', user.id)
						.single();
					me = profile || null;
				}
			}
			const myRole = String(me?.role || '').toLowerCase();
			if (myRole === 'editor') {
				const editable = Array.isArray(me?.permissions?.editableSections) ? me.permissions.editableSections : [];
				if (editable && editable.length > 0) {
					const set = new Set(editable);
					filteredSections = filteredSections.filter(s => set.has(s));
				} else {
					filteredSections = [];
				}
			}
		} catch(_) {}
        function openSectionModal(mode, section) {
            const isEdit = mode === 'edit';
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'block';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.background = 'rgba(0,0,0,0.4)';
            modal.style.zIndex = '10001';
            modal.innerHTML = `
                <div class="modal-content" style="max-width:520px; width:95%; margin: 6% auto; position: relative; z-index: 10002;">
                    <div class="modal-header">
                        <h2>${isEdit ? 'Edit Section' : 'Add New Section'}</h2>
                        <span class="close" onclick="this.closest('.modal').remove()">&times;</span>
                    </div>
                    <form id="sectionForm" style="padding: 10px 20px 20px;">
                        <div class="form-group">
                            <label for="secId">Section ID *</label>
                            <input type="text" id="secId" ${isEdit ? 'readonly' : ''} value="${isEdit ? section.id : ''}" placeholder="e.g., finance" required>
                        </div>
                        <div class="form-group">
                            <label for="secName">Name *</label>
                            <input type="text" id="secName" value="${isEdit ? section.name : ''}" placeholder="e.g., Finance" required>
                        </div>
                        <div class="form-group">
                            <label for="secIntro">Introduction (optional)</label>
                            <textarea id="secIntro" rows="3" placeholder="Short description shown on the hub card and section page.">${isEdit ? (section.intro || '') : ''}</textarea>
                        </div>
                        <div class="form-group">
                            <label>Icon</label>
                            <div style="display:flex;flex-direction:column;gap:10px;">
                                <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                                    <i id="iconPreview" class="${isEdit ? (section.icon || 'fas fa-th-large') : 'fas fa-th-large'}" style="font-size:20px;"></i>
                                    <input type="text" id="secIcon" value="${isEdit ? (section.icon || '') : ''}" placeholder="Font Awesome class (optional)" style="flex:1;min-width:200px;">
                                </div>
                                <input type="text" id="iconSearch" placeholder="Search icons (e.g., truck, user, cog)" style="padding:8px 10px;border:1px solid #ddd;border-radius:6px;">
                                <div id="iconPicker" style="display:grid;grid-template-columns:repeat(auto-fill, minmax(44px,1fr));gap:8px;max-height:160px;overflow:auto;border:1px solid #eee;padding:8px;border-radius:6px;background:#fff;"></div>
                                <div style="display:flex;align-items:center;gap:12px;flex-wrap:wrap;">
                                    <input type="url" id="secImage" value="${isEdit ? (section.image || '') : ''}" placeholder="Or paste image URL (PNG/SVG)" style="flex:1;min-width:200px;">
                                    <img id="imagePreview" src="${isEdit && section.image ? section.image : ''}" style="width:24px;height:24px;object-fit:contain;display:${isEdit && section.image ? 'block' : 'none'};" />
                                    <small>Image URL overrides icon if provided.</small>
                                </div>
                            </div>
                        </div>
                        <div class="form-group" style="display:flex;align-items:center;gap:8px;">
                            <input type="checkbox" id="secVisible" ${!isEdit || section.visible !== false ? 'checked' : ''}>
                            <label for="secVisible">Visible</label>
                        </div>
                        <div class="form-actions" style="display:flex;gap:10px;justify-content:flex-end;">
                            <button type="button" class="btn btn-secondary" onclick="this.closest('.modal').remove()">Cancel</button>
                            <button type="submit" class="btn btn-primary">Save</button>
                        </div>
                    </form>
                </div>
            `;
            document.body.appendChild(modal);

            const form = modal.querySelector('#sectionForm');
            const iconInput = modal.querySelector('#secIcon');
            const imageInput = modal.querySelector('#secImage');
            const iconPreview = modal.querySelector('#iconPreview');
            let imagePreview = modal.querySelector('#imagePreview');
            const iconSearch = modal.querySelector('#iconSearch');
            const iconPicker = modal.querySelector('#iconPicker');

            if (iconInput && iconPreview) {
                iconInput.addEventListener('input', () => {
                    const cls = iconInput.value.trim() || 'fas fa-th-large';
                    iconPreview.className = cls;
                });
            }
            if (imageInput) {
                imageInput.addEventListener('input', () => {
                    if (!imagePreview) imagePreview = modal.querySelector('#imagePreview');
                    const url = imageInput.value.trim();
                    if (imagePreview) {
                        if (url) {
                            imagePreview.src = url;
                            imagePreview.style.display = 'block';
                        } else {
                            imagePreview.src = '';
                            imagePreview.style.display = 'none';
                        }
                    }
                });
            }

            // Build and filter icon grid
            const faIcons = [
                'fas fa-th-large','fas fa-calculator','fas fa-truck','fas fa-cogs','fas fa-check-circle','fas fa-users',
                'fas fa-laptop-code','fas fa-chart-line','fas fa-gavel','fas fa-dollar-sign','fas fa-warehouse',
                'fas fa-industry','fas fa-clipboard-list','fas fa-boxes','fas fa-project-diagram','fas fa-database',
                'fas fa-balance-scale','fas fa-shield-alt','fas fa-network-wired','fas fa-tools','fas fa-file-alt'
            ];
            function renderIconGrid(filter='') {
                if (!iconPicker) return;
                const term = filter.toLowerCase();
                const list = faIcons.filter(cls => cls.includes(term.replace(/\s+/g,'-')));
                iconPicker.innerHTML = '';
                list.forEach(cls => {
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.style.border = '1px solid #ddd';
                    btn.style.borderRadius = '6px';
                    btn.style.padding = '8px';
                    btn.style.display = 'flex';
                    btn.style.justifyContent = 'center';
                    btn.style.alignItems = 'center';
                    btn.style.background = '#fff';
                    btn.style.cursor = 'pointer';
                    btn.title = cls;
                    btn.innerHTML = `<i class="${cls}" style="font-size:18px;"></i>`;
                    btn.addEventListener('click', () => {
                        iconInput.value = cls;
                        iconPreview.className = cls;
                    });
                    iconPicker.appendChild(btn);
                });
            }
            renderIconGrid('');
            if (iconSearch) {
                iconSearch.addEventListener('input', () => renderIconGrid(iconSearch.value));
            }

            form.addEventListener('submit', async (e) => {
                e.preventDefault();
                const idInput = modal.querySelector('#secId').value.trim().toLowerCase().replace(/\s+/g, '-');
                const nameInput = modal.querySelector('#secName').value.trim();
                const iconVal = iconInput ? iconInput.value.trim() : '';
                const imageVal = imageInput ? imageInput.value.trim() : '';
                const visibleInput = modal.querySelector('#secVisible').checked;
                const introVal = (modal.querySelector('#secIntro') && modal.querySelector('#secIntro').value) ? modal.querySelector('#secIntro').value.trim() : '';
                if (!idInput || !nameInput) return;

                if (!isEdit) {
                    try {
                        // Supabase-backed duplicate check to ensure single source of truth
                        if (window.supabaseClient) {
                            const { data: existingRow, error: existsErr } = await window.supabaseClient
                                .from('sections')
                                .select('section_id')
                                .eq('section_id', idInput)
                                .maybeSingle();
                            if (existsErr) {
                                console.warn('Section ID existence check failed (continuing to attempt create):', existsErr);
                            }
                            if (existingRow && existingRow.section_id) {
                                alert('A section with this ID already exists.');
                                return;
                            }
                        }
                    } catch (existsCheckErr) {
                        console.warn('Supabase duplicate check exception (continuing):', existsCheckErr);
                    }
                }
                // Admin-only creation guard
                try {
                    const { data: { user: authUser } } = await window.supabaseClient.auth.getUser();
                    if (!authUser) { alert('Please sign in again.'); return; }
                    const { data: profile } = await window.supabaseClient
                        .from('profiles')
                        .select('role')
                        .eq('id', authUser.id)
                        .single();
                    const role = String(profile?.role || '').toLowerCase();
                    if (!isEdit && role !== 'admin') { alert('Only admin can create new sections.'); return; }
                } catch (_) { /* if profile check fails, fall through and let RLS enforce */ }

                const iconClass = iconVal || 'fas fa-th-large';
                // Capture previous values for activity logging
                const prevNameForLog = isEdit && section ? (section.name || section.id || '') : '';
                if (isEdit) {
                    const idx = sectionOrder.findIndex(s => s.id === section.id);
                    if (idx !== -1) {
                        sectionOrder[idx] = { ...sectionOrder[idx], name: nameInput, icon: iconClass, image: imageVal || undefined, visible: visibleInput, intro: introVal };
                    }
                } else {
            const newSection = {
                        id: idInput,
                        name: nameInput,
                        icon: iconClass,
                        image: imageVal || undefined,
                        visible: visibleInput,
                        intro: introVal,
                order: sectionOrder.length + 1
            };
            sectionOrder.push(newSection);
                }
            // Save section to Supabase database
            const target = isEdit ? sectionOrder.find(s => s.id === section.id) : sectionOrder.find(s => s.id === idInput);
            
            // Narrow critical save to its own block; later UI updates won't mask a successful save
            let __saveOk = false;
            try {
                if (!(window.hubDatabase && window.hubDatabaseReady)) {
                    alert('Database not ready. Please try again.');
                    return;
                }
                if (isEdit) {
                    // Fetch previous config for tab/type diff
                    let __prevCfg = null;
                    try {
                        if (window.supabaseClient) {
                            const { data: prevRow } = await window.supabaseClient
                                .from('sections')
                                .select('config')
                                .eq('section_id', target.id)
                                .single();
                            __prevCfg = prevRow && prevRow.config ? prevRow.config : null;
                        }
                    } catch(_) {}
                    try {
                        await hubDatabase.updateSection(target);
                        console.log('Section updated in Supabase:', target);
                        // Log UPDATE_SECTION (include name change details when applicable)
                        try {
                            const oldName = prevNameForLog || target.id;
                            const newName = nameInput || target.name || target.id;
                            const meta = (oldName && newName && String(oldName) !== String(newName))
                                ? { oldName, newName }
                                : { name: newName };
                            hubDatabase.saveActivity({ action: 'UPDATE_SECTION', sectionId: target.id, metadata: meta });
                        } catch(_) {}
                        // Diff tabs/types and log changes
                        try {
                            const prev = (__prevCfg && typeof __prevCfg === 'object') ? __prevCfg : {};
                            const next = target && target.config && typeof target.config === 'object' ? target.config : {};
                            const prevTypes = Array.isArray(prev.types) ? prev.types.map(t => (t && t.id !== undefined ? String(t.id) : String(t))).filter(Boolean) : (Array.isArray(prev.tabs) ? prev.tabs.map(x => String(x)).filter(Boolean) : []);
                            const prevNames = new Map((Array.isArray(prev.types) ? prev.types : []).map(t => [String(t && t.id !== undefined ? t.id : t), String((t && t.name) || (t && t.id) || t || '')]));
                            if (Array.isArray(prev.tab_names)) {
                                (prev.tabs || []).forEach((id, i) => { const pid = String(id||''); if (!prevNames.has(pid)) prevNames.set(pid, String(prev.tab_names[i] || pid)); });
                            }
                            const nextTypes = Array.isArray(next.types) ? next.types.map(t => (t && t.id !== undefined ? String(t.id) : String(t))).filter(Boolean) : (Array.isArray(next.tabs) ? next.tabs.map(x => String(x)).filter(Boolean) : []);
                            const nextNames = new Map((Array.isArray(next.types) ? next.types : []).map(t => [String(t && t.id !== undefined ? t.id : t), String((t && t.name) || (t && t.id) || t || '')]));
                            if (Array.isArray(next.tab_names)) {
                                (next.tabs || []).forEach((id, i) => { const nid = String(id||''); if (!nextNames.has(nid)) nextNames.set(nid, String(next.tab_names[i] || nid)); });
                            }
                            const prevSet = new Set(prevTypes);
                            const nextSet = new Set(nextTypes);
                            // Created tabs
                            nextTypes.forEach(id => {
                                if (!prevSet.has(id)) {
                                    try { hubDatabase.saveActivity({ action: 'CREATE_TAB', sectionId: target.id, metadata: { tabId: id, name: nextNames.get(id) || id } }); } catch(_) {}
                                }
                            });
                            // Deleted tabs
                            prevTypes.forEach(id => {
                                if (!nextSet.has(id)) {
                                    try { hubDatabase.saveActivity({ action: 'DELETE_TAB', sectionId: target.id, metadata: { tabId: id, name: prevNames.get(id) || id } }); } catch(_) {}
                                }
                            });
                            // Renamed tabs (id exists in both but name changed)
                            nextTypes.forEach(id => {
                                if (prevSet.has(id)) {
                                    const oldName = prevNames.get(id) || id;
                                    const newName = nextNames.get(id) || id;
                                    if (String(oldName) !== String(newName)) {
                                        try { hubDatabase.saveActivity({ action: 'UPDATE_TAB', sectionId: target.id, metadata: { tabId: id, oldName, newName } }); } catch(_) {}
                                    }
                                }
                            });
                        } catch(_) {}
                    } catch (wrapperErr) {
                        console.warn('Wrapper update failed, attempting direct Supabase update', wrapperErr);
                        if (!window.supabaseClient) throw wrapperErr;
                        let existingCfg = {};
                        try {
                            const cur = await window.supabaseClient
                                .from('sections')
                                .select('config')
                                .eq('section_id', target.id)
                                .single();
                            if (!cur.error && cur.data && typeof cur.data.config === 'object') existingCfg = cur.data.config;
                        } catch (_) {}
                        const nextConfig = Object.assign({}, existingCfg, target.config || {}, { visible: target.visible !== false, intro: target.intro || '', order: target.order || 0 });
                        const { data: up, error: upErr } = await window.supabaseClient
                            .from('sections')
                            .update({ name: target.name, icon: target.icon, color: target.color, config: nextConfig })
                            .eq('section_id', target.id)
                            .select('section_id')
                            .maybeSingle();
                        if (upErr) throw upErr;
                        if (!up) throw new Error('No section row updated');
                        console.log('Section updated via direct Supabase:', up);
                    }
                } else {
                    try {
                        await hubDatabase.createSection(target);
                        console.log('Section created in Supabase:', target);
                        try { hubDatabase.saveActivity({ action: 'CREATE_SECTION', sectionId: target.id, metadata: { name: target.name || target.id } }); } catch(_) {}
                        // Log initial tabs/types as CREATE_TAB
                        try {
                            const cfg = target && target.config ? target.config : {};
                            const initTypes = Array.isArray(cfg.types) ? cfg.types.map(t => (t && t.id !== undefined ? String(t.id) : String(t))).filter(Boolean) : (Array.isArray(cfg.tabs) ? cfg.tabs.map(x => String(x)).filter(Boolean) : []);
                            const names = new Map((Array.isArray(cfg.types) ? cfg.types : []).map(t => [String(t && t.id !== undefined ? t.id : t), String((t && t.name) || (t && t.id) || t || '')]));
                            if (Array.isArray(cfg.tab_names)) {
                                (cfg.tabs || []).forEach((id, i) => { const nid = String(id||''); if (!names.has(nid)) names.set(nid, String(cfg.tab_names[i] || nid)); });
                            }
                            initTypes.forEach(id => {
                                try { hubDatabase.saveActivity({ action: 'CREATE_TAB', sectionId: target.id, metadata: { tabId: id, name: names.get(id) || id } }); } catch(_) {}
                            });
                        } catch(_) {}
                    } catch (wrapperErr) {
                        console.warn('Wrapper create failed, attempting direct Supabase upsert', wrapperErr);
                        if (!window.supabaseClient) throw wrapperErr;
                        const payload = {
                            section_id: target.id,
                            name: target.name,
                            icon: target.icon,
                            color: target.color,
                            config: { ...(target.config || {}), visible: target.visible !== false, intro: target.intro || '', order: target.order || 0 },
                            data: target.data || {}
                        };
                        const { data: up, error: upErr } = await window.supabaseClient
                            .from('sections')
                            .upsert(payload, { onConflict: 'section_id' })
                            .select('section_id')
                            .single();
                        if (upErr) throw upErr;
                        console.log('Section created via direct Supabase:', up);
                        try { hubDatabase.saveActivity({ action: 'CREATE_SECTION', sectionId: target.id, metadata: { name: target.name || target.id } }); } catch(_) {}
                        // Log initial tabs/types as CREATE_TAB
                        try {
                            const cfg = target && target.config ? target.config : {};
                            const initTypes = Array.isArray(cfg.types) ? cfg.types.map(t => (t && t.id !== undefined ? String(t.id) : String(t))).filter(Boolean) : (Array.isArray(cfg.tabs) ? cfg.tabs.map(x => String(x)).filter(Boolean) : []);
                            const names = new Map((Array.isArray(cfg.types) ? cfg.types : []).map(t => [String(t && t.id !== undefined ? t.id : t), String((t && t.name) || (t && t.id) || t || '')]));
                            if (Array.isArray(cfg.tab_names)) {
                                (cfg.tabs || []).forEach((id, i) => { const nid = String(id||''); if (!names.has(nid)) names.set(nid, String(cfg.tab_names[i] || nid)); });
                            }
                            initTypes.forEach(id => {
                                try { hubDatabase.saveActivity({ action: 'CREATE_TAB', sectionId: target.id, metadata: { tabId: id, name: names.get(id) || id } }); } catch(_) {}
                            });
                        } catch(_) {}
                    }
                }
                __saveOk = true;
            } catch (error) {
                console.error('Error saving section to Supabase:', error);
                try {
                    const ek = error || {};
                    const status = ek.status || ek.statusCode || '';
                    const code = ek.code || '';
                    const details = ek.details || '';
                    const message = ek.message || '';
                    const name = ek.name || '';
                    const origin = (typeof location !== 'undefined' ? location.origin : '');
                    const supaUrl = (window.CONFIG && window.CONFIG.SUPABASE_URL) || window.SUPABASE_URL || '';
                    let hint = '';
                    if (String(status) === '409' || String(code) === 'PGRST116') {
                        hint = ' The section ID already exists. It may have been updated.';
                    } else if (name === 'TypeError' && !status) {
                        hint = ` Network/CORS issue. Origin: ${origin} → ${supaUrl}`;
                    }
                    const head = 'Failed to save section' + (status ? ` (${status})` : '') + ':';
                    const body = message || details || code || name || 'Unknown error';
                    alert(`${head} ${body}${hint ? ' ' + hint : ''}`);
                } catch (_) {
                    alert('Failed to save section: Unknown error');
                }
                return;
            }

            // Post-save UI refresh (non-blocking)
            try {
                // Update local sectionOrder array
                // Section order is managed in Supabase database
                renderSectionsList();
                updateMainHubSections();
            } catch (uiErr) {
                console.warn('Post-save UI refresh failed (non-blocking)', uiErr);
            }
            
            try {
                const sessionRaw = localStorage.getItem('hubSession');
                if (sessionRaw) {
                    const sessionUser = JSON.parse(sessionRaw);
                    if (typeof updateHubCardsAccess === 'function') {
                        await updateHubCardsAccess(sessionUser);
                    }
                }
            } catch (e) { console.warn('Could not refresh hub cards access (non-blocking)', e); }
            
            try { modal.remove(); } catch(_) {}
            alert('Section saved successfully!');
            });
        }

        window.editSection = function(sectionId) {
            const section = sectionOrder.find(s => s.id === sectionId);
            if (!section) return;
            openSectionModal('edit', section);
        };
        
        window.deleteSection = async function(sectionId) {
            if (!confirm('Permanently remove this section from the hub?')) return;
            
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    // Capture name for logging before deletion
                    let sectionNameForDelete = '';
                    try {
                        const existingLocal = (Array.isArray(sectionOrder) ? sectionOrder : []).find(s => s && s.id === sectionId);
                        sectionNameForDelete = (existingLocal && existingLocal.name) ? existingLocal.name : '';
                    } catch(_) {}
                    try {
                        await hubDatabase.deleteSection(sectionId);
                        console.log('Section deleted from Supabase (wrapper):', sectionId);
                    } catch (wrapperErr) {
                        console.warn('Wrapper delete failed, attempting direct Supabase delete', wrapperErr);
                        if (!window.supabaseClient) throw wrapperErr;
                        // Delete dependent resources first to avoid FK constraints, then delete the section
                        try {
                            const { error: resErr } = await window.supabaseClient
                                .from('resources')
                                .delete()
                                .eq('section_id', sectionId);
                            if (resErr) console.warn('Resource delete returned error (continuing):', resErr);
                        } catch (resEx) { console.warn('Resource delete exception (continuing):', resEx); }
                        const { data: deleted, error: secErr } = await window.supabaseClient
                            .from('sections')
                            .delete()
                            .eq('section_id', sectionId)
                            .select('section_id')
                            .maybeSingle();
                        if (secErr) throw secErr;
                        if (!deleted) throw new Error('No section row deleted');
                        console.log('Section deleted via direct Supabase:', sectionId);
                    }
                    try {
                        if (window.hubDatabase && window.hubDatabaseReady) {
                            const meta = sectionNameForDelete ? { name: sectionNameForDelete } : {};
                            hubDatabase.saveActivity({ action: 'DELETE_SECTION', sectionId, metadata: meta });
                        }
                    } catch(_) {}
                    
                    // Remove from local sectionOrder array
                    const idx = sectionOrder.findIndex(s => s.id === sectionId);
                    if (idx !== -1) {
                    sectionOrder.splice(idx, 1);
                    sectionOrder.forEach((s, i) => { s.order = i + 1; });
                    // Section order is managed in Supabase database
                    }
                    
                    // Refresh the admin sections list
                    renderSectionsList();
                    
                    // Force reload sections from Supabase and update hub page
                    console.log('Reloading sections after deletion...');
                    await loadSectionsList();
                    
                    // Clear the debounce flag to force update
                    isUpdatingSections = false;
                    lastUpdateTime = 0;
                    
                    // Update the hub page
                    await updateMainHubSections();
                    
                    alert('Section deleted successfully!');
            } else {
                    alert('Database not ready. Please try again.');
                }
            } catch (error) {
                console.error('Error deleting section from Supabase:', error);
                const detail = (error && (error.message || error.details || error.code)) ? (error.message || error.details || error.code) : 'Unknown error';
                alert('Failed to delete section: ' + detail);
            }
        };
        
        window.addNewSection = function() {
            openSectionModal('add');
        };
        
        window.saveSectionOrder = async function() {
            updateSectionOrder();
            
            try {
                if (window.hubDatabase && window.hubDatabaseReady) {
                    // Update each section's order in Supabase via wrapper; fallback to direct Supabase batch update if wrapper fails
                    try {
                        for (const section of sectionOrder) {
                            await hubDatabase.updateSection(section);
                        }
                        console.log('Section order saved to Supabase (wrapper)');
                    } catch (wrapperErr) {
                        console.warn('Wrapper order save failed, attempting direct Supabase batch update', wrapperErr);
                        if (!window.supabaseClient) throw wrapperErr;
                        let failures = 0;
                        for (const section of sectionOrder) {
                            try {
                                let existingCfg = {};
                                try {
                                    const cur = await window.supabaseClient
                                        .from('sections')
                                        .select('config')
                                        .eq('section_id', section.id)
                                        .single();
                                    if (!cur.error && cur.data && typeof cur.data.config === 'object') existingCfg = cur.data.config;
                                } catch (_) {}
                                const nextConfig = Object.assign({}, existingCfg, section.config || {}, { order: section.order || 0, intro: section.intro || '', visible: section.visible !== false });
                                const { data: updated, error } = await window.supabaseClient
                                    .from('sections')
                                    .update({ config: nextConfig })
                                    .eq('section_id', section.id)
                                    .select('section_id')
                                    .maybeSingle();
                                if (error || !updated) {
                                    failures++;
                                    console.warn('Direct order update failed for', section.id, error || 'no row');
                                }
                            } catch (rowErr) {
                                failures++;
                                console.warn('Direct order update exception for', section.id, rowErr);
                            }
                        }
                        if (failures > 0) {
                            throw new Error('Order update failed for ' + failures + ' section(s)');
                        }
                        console.log('Section order saved to Supabase (direct fallback)');
                    }
                    
                    // Section order is managed in Supabase database
                    updateMainHubSections();
                    alert('Section order saved successfully!');
            } else {
                    alert('Database not ready. Please try again.');
                }
            } catch (error) {
                console.error('Error saving section order to Supabase:', error);
                const detail = (error && (error.message || error.details || error.code)) ? (error.message || error.details || error.code) : 'Unknown error';
                alert('Failed to save section order: ' + detail);
            }
        };
        
        window.resetSections = function() {
            // Check if user has admin role
            const session = localStorage.getItem('hubSession');
            if (!session) {
                alert('Please log in to reset sections');
                return;
            }
            
            const user = JSON.parse(session);
            if (user.role !== 'admin') {
                alert('Only administrators can reset sections');
                return;
            }
            
            if (confirm('Reset sections to a minimal default with a single example?')) {
                sectionOrder = [
                    { id: 'example', name: 'Example', icon: 'fas fa-th-large', visible: true, order: 1, intro: getDefaultIntroForSection('example') || 'Your first example section. Add more from the admin panel.' }
                ];
                // Section order is managed in Supabase database
                renderSectionsList();
                updateMainHubSections();
                alert('Sections reset to minimal default!');
            }
        };
        // Legacy ensureHubCard removed — cards are built only from Supabase via updateMainHubSections

        // Legacy updateHubCardContent removed — cards are rebuilt from Supabase in updateMainHubSections

        // Normalize icon classes for Font Awesome 6
        function normalizeIconClass(cls) {
            if (!cls || typeof cls !== 'string') return 'fa-solid fa-table-cells-large';
            let c = cls.trim();
            // If already uses fa-solid/fa-regular/fa-brands, keep
            if (/\bfa-(solid|regular|light|thin|duotone|brands)\b/.test(c)) return c;
            // Convert legacy 'fas ' to 'fa-solid '
            c = c.replace(/\bfas\b/, 'fa-solid').replace(/\bfar\b/, 'fa-regular').replace(/\bfab\b/, 'fa-brands');
            // Ensure there is a style prefix
            if (!/\bfa-\w+\b/.test(c) || !/\bfa-\w+\b.*\bfa-/.test('fa ' + c)) {
                // If only an icon name provided, add fa-solid
                if (!/\bfa-(solid|regular|brands)\b/.test(c)) {
                    c = 'fa-solid ' + c;
                }
            }
            return c;
        }

        function getDefaultIntroForSection(sectionId) {
            const map = {
                'costing': 'Guides and tools for cost analysis, budgeting, and ROI planning.',
                'supply-planning': 'Demand forecasting, inventory optimization, and supplier planning resources.',
                'operations': 'Process improvement, SOPs, production metrics, and maintenance guidance.',
                'quality': 'Quality management practices, control procedures, and compliance standards.',
                'hr': 'People operations policies, templates, onboarding, and workforce resources.',
                'it': 'IT systems, tooling, security, and operational best practices.',
                'sales': 'Sales playbooks, marketing assets, and performance dashboards.',
                'compliance': 'Policies, legal, and regulatory guidance with reusable templates.',
                'example': 'Your first example section. Add more from the admin panel.'
            };
            return map[sectionId] || '';
        }
        function seedSectionIntrosIfMissing() {
            try {
                const saved = null;
                if (!saved) return [];
                const arr = JSON.parse(saved);
                let changed = false;
                arr.forEach(s => {
                    if (!s.intro || typeof s.intro !== 'string' || s.intro.trim() === '') {
                        s.intro = getDefaultIntroForSection(s.id);
                        changed = true;
                    }
                });
                if (changed) {
                    localStorage.setItem('sectionOrder', JSON.stringify(arr));
                }
                return arr;
            } catch (_) { return []; }
        }

        function escapeHtml(text) {
            try {
                const div = document.createElement('div');
                div.textContent = text || '';
                return div.innerHTML;
            } catch (_) { return ''; }
        }

        function truncate(text, maxLen) {
            const t = String(text || '');
            if (t.length <= maxLen) return t;
            return t.slice(0, Math.max(0, maxLen - 1)) + '…';
        }
        // Background image support for sections (random, session-only)
        let BACKGROUND_IMAGES = [];
        // Session-only seed and map for background assignment (not persisted)
        let BG_SESSION_SEED = String(Date.now()) + ':' + Math.random();
        let SECTION_BG_MAP = {};
        let SECTION_BG_READY = false;

        // Load persistent section->image mapping from database (consistent across users)
        async function loadSectionBackgroundsFromDb() {
            try {
                if (!(window.supabaseClient && window.supabaseClient.from)) return;
                const { data, error } = await window.supabaseClient
                    .from('section_backgrounds')
                    .select('section_id, image_url');
                if (error) return;
                const map = {};
                (Array.isArray(data) ? data : []).forEach(r => { if (r && r.section_id && r.image_url) map[r.section_id] = r.image_url; });
                SECTION_BG_MAP = map;
                SECTION_BG_READY = true;
            } catch(_) {}
        }
        async function ensureBackgroundImagesLoaded() {
            try {
                if (Array.isArray(BACKGROUND_IMAGES) && BACKGROUND_IMAGES.length > 0) return;
                try {
                    const bust = Date.now();
                    const resp = await fetch(`background-pic/manifest.json?t=${bust}`, { cache: 'no-store' });
                    if (resp && resp.ok) {
                        const data = await resp.json();
                        if (Array.isArray(data) && data.length > 0) {
                            BACKGROUND_IMAGES = data.map(p => `background-pic/${p}`).sort();
                            return;
                        }
                    }
                } catch (_) {}
                // Fallback baked-in list (works even if manifest.json is empty)
                BACKGROUND_IMAGES = [
                    'background-pic/159484_L.png','background-pic/162053_L.png','background-pic/162054_L.png','background-pic/162058_L.png',
                    'background-pic/162062_L.png','background-pic/168817_L.png','background-pic/171327_Y.png','background-pic/537081_L.png',
                    'background-pic/537082_K.png','background-pic/560846_L.png'
                ].sort();
            } catch (_) { /* keep defaults */ }
        }
        // Optimize background images client-side and cache results
        function computeManifestVersion() {
            try {
                return String(BACKGROUND_IMAGES.join('|')).length + ':' + BACKGROUND_IMAGES.length;
            } catch (_) { return 'v0'; }
        }
        // Try to infer GitHub repo info from Pages URL; can be overridden with window.GH_OWNER/GH_REPO/GH_BRANCH
        function getGithubRepoInfo() {
            try {
                const owner = (window.GH_OWNER || '').trim();
                const repo = (window.GH_REPO || '').trim();
                const branch = (window.GH_BRANCH || '').trim();
                if (owner && repo) {
                    return { owner, repo, branches: branch ? [branch] : ['gh-pages','main','master'] };
                }
                const host = String(location.hostname || '').toLowerCase();
                if (!/\.github\.io$/.test(host)) return null;
                const inferredOwner = host.split('.github.io')[0];
                const firstPath = String(location.pathname || '/').split('/').filter(Boolean)[0] || '';
                // If it's a project page, firstPath is repo; for user/org page, repo is owner.github.io
                const inferredRepo = firstPath || `${inferredOwner}.github.io`;
                return { owner: inferredOwner, repo: inferredRepo, branches: ['gh-pages','main','master'] };
            } catch (_) { return null; }
        }
        async function getFilesFromGitHub() {
            try {
                const info = getGithubRepoInfo();
                if (!info) return [];
                const { owner, repo, branches } = info;
                const headers = { 'Accept': 'application/vnd.github+json' };
                for (const br of branches) {
                    try {
                        const url = `https://api.github.com/repos/${owner}/${repo}/contents/background-pic?ref=${encodeURIComponent(br)}`;
                        const resp = await fetch(url, { headers, cache: 'no-store' });
                        if (!resp.ok) continue;
                        const data = await resp.json();
                        if (Array.isArray(data) && data.length > 0) {
                            const files = data
                                .filter(x => x && x.type === 'file' && /\.(png|jpe?g|gif|svg|webp)$/i.test(x.name || ''))
                                .map(x => `background-pic/${x.name}`);
                            if (files.length > 0) return files;
                        }
                    } catch (_) { /* try next branch */ }
                }
                return [];
            } catch (_) { return []; }
        }
        // Validate that manifest images actually exist by attempting to load them
        async function filterExistingBackgroundImages(files) {
            // Skip probing to avoid blocking load; assume listed files exist
            try { return Array.isArray(files) ? files : []; } catch (_) { return Array.isArray(files) ? files : []; }
        }
        function getOptimizedMapping() {
            try {
                const v = computeManifestVersion();
                const raw = localStorage.getItem('bgOptimizedMap') || '{}';
                const ver = localStorage.getItem('bgOptimizedVersion') || '';
                let map = {};
                try { map = JSON.parse(raw); } catch(_) { map = {}; }
                if (ver !== v) {
                    localStorage.removeItem('bgOptimizedMap');
                    localStorage.setItem('bgOptimizedVersion', v);
                    return {};
                }
                return map;
            } catch (_) { return {}; }
        }
        function setOptimizedMapping(map) {
            try {
                localStorage.setItem('bgOptimizedMap', JSON.stringify(map));
                if (!localStorage.getItem('bgOptimizedVersion')) {
                    localStorage.setItem('bgOptimizedVersion', computeManifestVersion());
                }
            } catch (_) {}
        }
        async function getOptimizedImageUrl(src, width = 1400, height = 0, quality = 0.74) {
            try {
                if (!src || typeof src !== 'string') return src;
                if (/^data:/i.test(src)) return src;
                if (/wsrv\.nl\//i.test(src)) return src; // already proxied
                // Skip proxy in local/dev or non-http contexts (e.g., file://, localhost)
                try {
                    const pageProto = String(location.protocol || '').toLowerCase();
                    const pageHost = String(location.hostname || '').toLowerCase();
                    if (pageProto === 'file:' || pageHost === 'localhost' || pageHost === '127.0.0.1') return src;
                } catch(_) {}
                // Convert to absolute URL for proxying
                const abs = (function(p){ try { return new URL(p, document.baseURI).href; } catch(_) { return p; } })(src);
                if (!/^https?:\/\//i.test(abs)) return src; // only proxy http(s)
                const w = Math.max(1, Math.floor(Number(width) || 1400));
                const h = Math.max(0, Math.floor(Number(height) || 0));
                const q = Math.min(100, Math.max(10, Math.round((Number(quality) || 0.74) * 100)));
                const params = [`url=${encodeURIComponent(abs)}`, `w=${w}`, `q=${q}`, `output=webp`];
                if (h > 0) params.push(`h=${h}`);
                return `https://images.weserv.nl/?${params.join('&')}`;
            } catch (_) { return src; }
        }

        function getBackgroundImageForSection(sectionId) {
            try {
                if (!Array.isArray(BACKGROUND_IMAGES) || BACKGROUND_IMAGES.length === 0) return null;
                // Use a session-only seed to derive a stable index within a single load
                const h = hashCode(`${BG_SESSION_SEED}|${sectionId}`);
                const idx = Math.abs(h) % BACKGROUND_IMAGES.length;
                return BACKGROUND_IMAGES[idx];
            } catch (_) {
                // Fallback to a deterministic choice
                const idx = Math.abs(hashCode(String(sectionId))) % BACKGROUND_IMAGES.length;
                return BACKGROUND_IMAGES[idx];
            }
        }

        function hashCode(str) {
            let h = 0; for (let i = 0; i < str.length; i++) { h = (h << 5) - h + str.charCodeAt(i); h |= 0; }
            return h;
        }

        async function applyCardBackground(sectionCfg) {
            try {
                const card = document.querySelector(`.hub-card[onclick="navigateToSection('${sectionCfg.id}')"]`);
                if (!card) return;
                // Respect global/user setting: default disabled
                try {
                    if (typeof backgroundsDisabled === 'function' && backgroundsDisabled()) {
                        try { card.style.removeProperty('background-image'); } catch(_) {}
                        try { card.classList.remove('bg-ready'); } catch(_) {}
                        try { card.removeAttribute('data-bg-url'); } catch(_) {}
                        return;
                    }
                } catch(_) {}
                // Prefer per-section provided image if available
                let img = null;
                try {
                    const explicit = sectionCfg.bgImage || sectionCfg.background || sectionCfg.image;
                    if (explicit && String(explicit).trim().length > 0) {
                        img = String(explicit).trim();
                    }
                } catch (_) {}
                // Next prefer pre-assigned unique map if available
                if (!img) {
                    try {
                        const mapped = SECTION_BG_MAP && SECTION_BG_MAP[sectionCfg.id];
                        if (mapped) img = mapped;
                    } catch(_) {}
                }
                // Do not fallback to random; wait for DB mapping for consistency
                if (!img) return;
                if (!img) return;
                // Resize/convert via online proxy before applying (with fallback)
                try {
                    const cand = await getOptimizedImageUrl(img, 1200, 0, 0.8);
                    if (cand && cand !== img) {
                        await new Promise((resolve) => {
                            try {
                                const t = new Image();
                                t.onload = () => resolve(true);
                                t.onerror = () => resolve(false);
                                t.src = cand;
                            } catch(_) { resolve(false); }
                        }).then((ok)=>{ if (ok) img = cand; });
                    }
                } catch (_) {}
                // Idempotence guard: skip if already applied
                try {
                    const currentUrl = card.getAttribute('data-bg-url') || '';
                    if (currentUrl === img) return;
                } catch(_) {}
                card.style.backgroundImage = `linear-gradient(rgba(0,0,0,0.35), rgba(0,0,0,0.35)), url('${img}')`;
                card.style.backgroundSize = 'cover';
                card.style.backgroundPosition = 'center';
                card.style.backgroundRepeat = 'no-repeat';
                // Mark card as ready for contrast styles
                try { card.classList.add('bg-ready'); } catch (_) {}
                try { card.setAttribute('data-bg-url', img); } catch(_) {}
            } catch (_) {}
        }

        // Regenerate manifest and precompute thumbnails (session-only; no localStorage)
        async function regenerateBackgroundManifestAndThumbnails() {
            // Attempt to read fresh manifest.json, fall back to current BACKGROUND_IMAGES
            let files = [];
            try {
                const bust = Date.now();
                const resp = await fetch(`background-pic/manifest.json?t=${bust}`, { cache: 'no-store' });
                if (resp.ok) {
                    const data = await resp.json();
                    if (Array.isArray(data) && data.length > 0) {
                        files = data.map(p => `background-pic/${p}`);
                    }
                }
            } catch (_) {}
            if (!Array.isArray(files) || files.length === 0) {
                try { files = Array.isArray(BACKGROUND_IMAGES) ? BACKGROUND_IMAGES.slice() : []; } catch(_) { files = []; }
            }
            try { files = await filterExistingBackgroundImages(files); } catch(_) {}
            // Online refresh via GitHub API
            try {
                let ghFiles = await getFilesFromGitHub();
                ghFiles = await filterExistingBackgroundImages(ghFiles);
                if (Array.isArray(ghFiles) && ghFiles.length > 0) {
                    files = ghFiles;
                }
            } catch(_) {}
            // Warm optimized thumbnails with small concurrency
            try {
                const queue = files.slice();
                const concurrency = 3;
                const workers = new Array(concurrency).fill(0).map(async () => {
                    while (queue.length > 0) {
                        const src = queue.shift();
                        try { await getOptimizedImageUrl(src, 640, 360, 0.82); } catch (_) {}
                    }
                });
                await Promise.all(workers);
            } catch (_) {}
        }

        // Admin utility: reshuffle all backgrounds and re-apply to hub cards
        window.reshuffleBackgrounds = async function() {
            // Verify admin via Supabase profile to avoid stale local session checks
            try {
                if (!window.supabaseClient) { alert('Not signed in'); return; }
                const { data: { user: authUser } } = await window.supabaseClient.auth.getUser();
                if (!authUser) { alert('Not signed in'); return; }
                const { data: prof, error: pErr } = await window.supabaseClient
                    .from('profiles')
                    .select('role, permissions')
                    .eq('id', authUser.id)
                    .single();
                if (pErr || !prof) { alert('Profile not found'); return; }
                const role = String(prof.role || '').toLowerCase();
                const canManage = !!(prof.permissions && prof.permissions.canManageUsers);
                if (!(role === 'admin' || canManage)) { alert('Only admins can reshuffle backgrounds'); return; }
            } catch (__) { alert('Unable to verify permissions'); return; }
            try {
                // Regenerate manifest and ensure images
                await regenerateBackgroundManifestAndThumbnails();
                await ensureBackgroundImagesLoaded();
                // Build unique mapping for all visible sections and persist
                const cards = Array.from(document.querySelectorAll('.hub-card'));
                const sectionIds = cards.map(c => c.getAttribute('data-section-id')).filter(Boolean);
                const imgs = BACKGROUND_IMAGES.slice();
                for (let i = imgs.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [imgs[i], imgs[j]] = [imgs[j], imgs[i]]; }
                const used = new Set();
                const newMap = {};
                let cursor = 0;
                for (const sid of sectionIds) {
                    let picked = null;
                    for (let k = 0; k < imgs.length; k++) {
                        const candidate = imgs[(cursor + k) % imgs.length];
                        if (!used.has(candidate)) { picked = candidate; cursor = (cursor + k + 1) % imgs.length; break; }
                    }
                    if (!picked) { picked = imgs[cursor % imgs.length]; cursor = (cursor + 1) % imgs.length; }
                    newMap[sid] = picked;
                    used.add(picked);
                }
                if (window.supabaseClient && sectionIds.length > 0) {
                    const rows = Object.keys(newMap).map(section_id => ({ section_id, image_url: newMap[section_id] }));
                    const chunkSize = 100;
                    for (let start = 0; start < rows.length; start += chunkSize) {
                        const chunk = rows.slice(start, start + chunkSize);
                        const { error: upErr } = await window.supabaseClient
                            .from('section_backgrounds')
                            .upsert(chunk, { onConflict: 'section_id' });
                        if (upErr) throw upErr;
                    }
                }
                SECTION_BG_MAP = newMap;
                await updateMainHubSections();
                // Update shuffleAt in site_settings so other clients can react
                try {
                    const { data } = await window.supabaseClient
                        .from('site_settings')
                        .select('value')
                        .eq('key', 'backgrounds')
                        .single();
                    let current = data && data.value; try { if (typeof current === 'string') current = JSON.parse(current); } catch(_) {}
                    const next = Object.assign({}, current || {}, { shuffleAt: new Date().toISOString() });
                    await window.supabaseClient
                        .from('site_settings')
                        .upsert({ key: 'backgrounds', value: next }, { onConflict: 'key' });
                } catch(_) {}
                alert('Backgrounds reshuffled');
            } catch (e) {
                console.warn('Reshuffle failed', e);
            }
        };
        
        // Helpers for dynamic card tab rendering (mirror section page)
            function normalizeTypeId(raw) {
            try {
                const t = String(raw || '').toLowerCase().trim();
                if (t === 'playbooks' || t === 'playbook') return 'playbooks';
                if (t === 'box-links' || t === 'boxlinks' || t === 'boxlink' || t === 'box') return 'boxLinks';
                if (t === 'dashboards' || t === 'dashboard') return 'dashboards';
                return t;
            } catch (_) { return String(raw || '').toLowerCase(); }
        }
        function iconForType(tid) {
            const t = normalizeTypeId(tid);
            if (t === 'playbooks') return 'fas fa-book';
            if (t === 'boxLinks') return 'fas fa-link';
            if (t === 'dashboards') return 'fas fa-chart-bar';
            return 'fas fa-folder';
        }
        let isUpdatingSections = false;
        let lastUpdateTime = 0;
        
        async function updateMainHubSections() {
            console.log('Loading sections from Supabase...');
            
            // Check if hubDatabase is available
            if (!window.hubDatabase || !window.hubDatabaseReady) {
                console.warn('Database not ready, keeping existing content');
                return; // Keep the existing content, don't replace it
            }
            
            const now = Date.now();
            if (isUpdatingSections) {
                console.log('Update already in progress, skipping...');
                return;
            }
            
            // Prevent too frequent updates (debounce)
            if (now - lastUpdateTime < 1000) {
                console.log('Update called too frequently, skipping...');
                return;
            }
            
            isUpdatingSections = true;
            lastUpdateTime = now;
            
            const hubGrid = document.querySelector('.hub-grid');
            if (!hubGrid) {
                console.error('Hub grid not found');
                isUpdatingSections = false;
                return;
            }
            
            // Load sections from Supabase database
            let visibleSections = [];
            
            try {
                // Wait for database to be ready
                let retries = 0;
                const maxRetries = 20;
                while (retries < maxRetries && (!window.hubDatabase || !window.hubDatabaseReady)) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    retries++;
                }
                
                if (window.hubDatabase && window.hubDatabaseReady && typeof hubDatabase.getAllSections === 'function') {
                    // Read sections from Supabase wrapper with a robust direct-query fallback
                    let sections = await hubDatabase.getAllSections();
                    if ((!sections || sections.length === 0) && window.supabaseClient) {
                        try {
                            const { data: directSections } = await window.supabaseClient
                                .from('sections')
                                .select('*')
                                .order('name', { ascending: true });
                            sections = Array.isArray(directSections) ? directSections : [];
                        } catch (_) {}
                    }
                    console.log('Loaded sections from database:', sections);
                    
                    if (sections && sections.length > 0) {
                        // Trust Supabase RLS to return only accessible sections; apply only visibility and order
                        visibleSections = sections
                            .filter(s => s.config?.visible !== false)
                            .sort((a,b) => (a.config?.order||0) - (b.config?.order||0));
                    } else {
                        console.warn('No sections found in database');
                    }
                } else {
                    console.error('Database not available');
                }
            } catch (error) {
                console.error('Error loading sections from database:', error);
            }
            
            // If no sections found after filtering, preserve existing content if present
            if (visibleSections.length === 0) {
                console.log('No sections to display');
                try {
                    const hasExisting = (hubGrid.innerHTML || '').trim().length > 0;
                    if (!hasExisting) {
                        hubGrid.innerHTML = '<div class="no-sections">No sections available. Please contact an administrator to add content.</div>';
                    }
                } catch(_) {}
                isUpdatingSections = false;
                return;
            }
            const prettyName = (id) => String(id || '').replace(/-/g,' ').replace(/\b\w/g, c => c.toUpperCase());
            const escapeHtml = (t) => { const d = document.createElement('div'); d.textContent = t || ''; return d.innerHTML; };
            const truncate = (t, n) => { const s = String(t||''); return s.length>n ? s.slice(0,n-1)+'…' : s; };
            
            // Normalize section data for rendering (Supabase is the single source of truth)
            const normalizeSection = (section) => ({
                id: section.section_id || section.id,
                name: section.name,
                description: section.description,
                intro: (section.config && typeof section.config.intro === 'string') ? section.config.intro : '',
                icon: section.icon || 'fas fa-th-large',
                image: section.image,
                visible: !(section.config && section.config.visible === false),
                order: (section.config && Number.isFinite(section.config.order)) ? section.config.order : (section.order || 0),
                config: section.config || {}
            });
            
            // Normalize all sections
            visibleSections = visibleSections.map(normalizeSection);

            // Build new content first
            let newContent = '';
            
            // Pre-assign a pool of images large enough for all sections, allowing duplicates when needed
            try {
                if (!backgroundsDisabled() && Array.isArray(BACKGROUND_IMAGES) && BACKGROUND_IMAGES.length > 0) {
                    const needed = visibleSections.length;
                    // Create a pool with no duplicates until we exhaust the list
                    const imgs = BACKGROUND_IMAGES.slice();
                    // Shuffle
                    for (let i = imgs.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [imgs[i], imgs[j]] = [imgs[j], imgs[i]];
                    }
                    // Assign unique images first, then allow repeats if needed
                    const used = new Set();
                    let cursor = 0;
                    visibleSections.forEach((s) => {
                        if (SECTION_BG_MAP[s.id]) { used.add(SECTION_BG_MAP[s.id]); }
                    });
                    for (const s of visibleSections) {
                        if (SECTION_BG_MAP[s.id]) continue;
                        // Find next unused image
                        let picked = null;
                        for (let k = 0; k < imgs.length; k++) {
                            const candidate = imgs[(cursor + k) % imgs.length];
                            if (!used.has(candidate)) { picked = candidate; cursor = (cursor + k + 1) % imgs.length; break; }
                        }
                        if (!picked) { picked = imgs[cursor % imgs.length]; cursor = (cursor + 1) % imgs.length; }
                        SECTION_BG_MAP[s.id] = picked;
                        used.add(picked);
                    }
                }
            } catch (_) {}

            for (const section of visibleSections) {
                try {
                    // Build types list to mirror the section detail tabs (align with section page fallbacks)
                    let typesList = [];
                    try {
                        const cfg = section.config || {};
                        const tabsArr = Array.isArray(cfg.tabs) ? cfg.tabs : [];
                        const tabNames = Array.isArray(cfg.tab_names) ? cfg.tab_names : [];
                        const typesArr = Array.isArray(cfg.types) ? cfg.types : [];
                        const typesById = new Map(typesArr.map(t => [String(t?.id || '').trim(), t]));
                        let visibleTypes = [];
                        if (tabsArr.length > 0) {
                            visibleTypes = tabsArr.map((rawId, i) => {
                                const id = String(rawId || '').trim();
                                const base = typesById.get(id) || {};
                                const name = String((tabNames[i] !== undefined && tabNames[i] !== null && String(tabNames[i]).trim()) ? tabNames[i] : (base.name || id)).trim();
                                const icon = String(base.icon || '').trim();
                                return { id, name, icon };
                            }).filter(t => t.id);
                        } else {
                            // Fallback 1: configured types (not hidden)
                            visibleTypes = (typesArr || [])
                                .filter(t => t && !t.hidden)
                                .map(t => {
                                    const id = String(t.id || t.name || '').trim();
                                    return id ? { id, name: t.name || id, icon: t.icon || '' } : null;
                                })
                                .filter(Boolean);
                            // Fallback 2: derive ids from tab_names if still empty
                            if (visibleTypes.length === 0 && tabNames.length > 0) {
                                visibleTypes = tabNames.map((nm) => {
                                    const id = String(nm || '').trim();
                                    const base = typesById.get(id) || {};
                                    const icon = String(base.icon || '').trim();
                                    return id ? { id, name: String(nm || id).trim(), icon } : null;
                                }).filter(Boolean);
                            }
                        }
                        typesList = visibleTypes;
                    } catch (_) {}
                    // If still empty, derive from resources (distinct types for this section)
                    if ((!typesList || typesList.length === 0) && window.supabaseClient) {
                        try {
                            const { data } = await window.supabaseClient
                                .from('resources')
                                .select('type')
                                .eq('section_id', section.id);
                            const raw = Array.isArray(data) ? data.map(r => String(r.type||'').trim()).filter(Boolean) : [];
                            const mapped = raw.map(v => v.toLowerCase() === 'playbook' ? 'playbooks' : v.toLowerCase() === 'link' ? 'box-links' : v.toLowerCase() === 'dashboard' ? 'dashboards' : v);
                            const uniq = Array.from(new Set(mapped));
                            typesList = uniq.map(id => ({ id, name: id === 'playbooks' ? 'Playbooks' : id === 'box-links' ? 'Box Links' : id === 'dashboards' ? 'Dashboards' : id, icon: '' }));
                        } catch (_) {}
                    }
                    // No legacy defaults: if nothing is configured and no resources exist, show nothing
                    if (!typesList || typesList.length === 0) {
                        typesList = [];
                    }
                    // Do not auto-augment; mirror only the configured tabs (or robust defaults)

                    const statsHTML = typesList.map(t => {
                        const nid = normalizeTypeId(t.id);
                        const iconVal = (t.icon || '').trim();
                        const isImg = /^(https?:|data:)|\.(svg|png|jpe?g|gif)$/i.test(iconVal);
                        const iconHtml = iconVal && isImg
                            ? `<img src="${iconVal}" alt="" style="width:18px;height:18px;object-fit:contain;vertical-align:-2px;" />`
                            : `<i class="${iconVal ? normalizeIconClass(iconVal) : iconForType(nid)}"></i>`;
                        return `<span>${iconHtml} <span id="${section.id}-${nid}">0</span> ${escapeHtml(t.name || nid)}</span>`;
                    }).join(' ');
                    
                    const cardHTML = `
                <div class="hub-card" id="card-${section.id}" data-section-id="${section.id}" onclick="navigateToSection('${section.id}')">
                    <div class="card-header">
                        <div class="card-icon"><i class="${escapeHtml(section.icon || 'fas fa-th-large')}"></i></div>
                        <div class="card-title">
                            <h3>${escapeHtml(section.name || prettyName(section.id))}</h3>
                            <p class="card-intro">${escapeHtml(truncate(section.intro || '', 120))}</p>
                        </div>
                    </div>
                    <div class="card-stats" id="${section.id}-stats">${statsHTML}</div>
                </div>`;
                    newContent += cardHTML;
                } catch (e) {
                    console.error('Card build failed for section', section && section.id, e);
                    // Skip this section if it fails to build
                }
                // Background will be scheduled lazily
            }
            
            // Replace grid content all at once to prevent flashing
            hubGrid.innerHTML = newContent;
            // Ensure the main UI is visible once content is ready
            try {
                const loadingScreen = document.getElementById('loadingScreen');
                const mainContent = document.getElementById('mainContent');
                if (loadingScreen) loadingScreen.style.display = 'none';
                if (mainContent) mainContent.style.display = 'block';
            } catch (_) {}
            
            // Stats for currently built sections
            updateSectionStats();
            // Initialize lazy loading for backgrounds (skip when disabled)
            if (!backgroundsDisabled()) initBackgroundLazyLoad(visibleSections);
            updateBackgroundToggleButton();
            console.log('=== UPDATE MAIN HUB SECTIONS COMPLETE ===');
            
            // Reset the flag
            isUpdatingSections = false;
        }
        // Select all sections for a user
        window.selectAllSections = async function(userId) {
            window.__assignmentsBatchActive = true;
            // Use the same full list as loader (ignore visibility)
            let allSections = [];
            try {
                let rows = window.hubDatabase && window.hubDatabaseReady ? await hubDatabase.getAllSections() : [];
                if ((!rows || rows.length === 0) && window.supabaseClient) {
                    const { data: direct } = await window.supabaseClient
                        .from('sections')
                        .select('section_id')
                        .order('section_id', { ascending: true });
                    rows = Array.isArray(direct) ? direct : [];
                }
                allSections = (Array.isArray(rows) ? rows : []).map(r => r.section_id || r.id).filter(Boolean);
                if (allSections.length === 0) allSections = await getAllAvailableSections();
            } catch(_) { allSections = await getAllAvailableSections(); }
            const card = document.querySelector(`.assignment-card[data-user-id="${userId}"]`);
            for (const sectionId of allSections) {
                const checkbox = card ? card.querySelector(`input[type="checkbox"][value="${sectionId}"]`) : document.querySelector(`input[value="${sectionId}"][onchange*="updateUserSectionAccess(${userId}"]`);
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                    await updateUserSectionAccess(userId, sectionId, true);
                }
            }
            window.__assignmentsBatchActive = false;
            try {
                let username = '';
                if (window.supabaseClient) {
                    const { data: u } = await window.supabaseClient.from('profiles').select('username').eq('id', userId).single();
                    username = u?.username || '';
                }
                showToast(`Assigned all sections ${username ? 'to ' + username : ''}`, 'success');
            } catch(_) { try { showToast('Assigned all sections', 'success'); } catch(_) {} }
        };
        
        // Clear all sections for a user
        window.clearAllSections = async function(userId) {
            window.__assignmentsBatchActive = true;
            // Use the same full list as loader (ignore visibility)
            let allSections = [];
            try {
                let rows = window.hubDatabase && window.hubDatabaseReady ? await hubDatabase.getAllSections() : [];
                if ((!rows || rows.length === 0) && window.supabaseClient) {
                    const { data: direct } = await window.supabaseClient
                        .from('sections')
                        .select('section_id')
                        .order('section_id', { ascending: true });
                    rows = Array.isArray(direct) ? direct : [];
                }
                allSections = (Array.isArray(rows) ? rows : []).map(r => r.section_id || r.id).filter(Boolean);
                if (allSections.length === 0) allSections = await getAllAvailableSections();
            } catch(_) { allSections = await getAllAvailableSections(); }
            const card = document.querySelector(`.assignment-card[data-user-id="${userId}"]`);
            for (const sectionId of allSections) {
                const checkbox = card ? card.querySelector(`input[type="checkbox"][value="${sectionId}"]`) : document.querySelector(`input[value="${sectionId}"][onchange*="updateUserSectionAccess(${userId}"]`);
                if (checkbox && checkbox.checked) {
                    checkbox.checked = false;
                    await updateUserSectionAccess(userId, sectionId, false);
                }
            }
            window.__assignmentsBatchActive = false;
            try {
                let username = '';
                if (window.supabaseClient) {
                    const { data: u } = await window.supabaseClient.from('profiles').select('username').eq('id', userId).single();
                    username = u?.username || '';
                }
                showToast(`Cleared all sections ${username ? 'for ' + username : ''}`, 'success');
            } catch(_) { try { showToast('Cleared all sections', 'success'); } catch(_) {} }
        };
        // Ensure selected image actually loads; if not, remap to another available image
        function resolveValidBackground(sectionId, attempts = 0) {
            return new Promise((resolve) => {
                try {
                    if (!Array.isArray(BACKGROUND_IMAGES) || BACKGROUND_IMAGES.length === 0) return resolve(null);
                    const candidate = getBackgroundImageForSection(sectionId);
                    if (!candidate) return resolve(null);
                    const testImg = new Image();
                    testImg.onload = async () => {
                        try {
                            const optimized = await getOptimizedImageUrl(candidate);
                            resolve(optimized || candidate);
                        } catch (_) {
                            resolve(candidate);
                        }
                    };
                    testImg.onerror = () => {
                        try {
                            const key = 'sectionBackgrounds';
                            const raw = localStorage.getItem(key);
                            const map = raw ? JSON.parse(raw) : {};
                            if (map && map[sectionId]) {
                                delete map[sectionId];
                                localStorage.setItem(key, JSON.stringify(map));
                            }
                        } catch (_) {}
                        if (attempts < Math.min(BACKGROUND_IMAGES.length, 50)) {
                            resolveValidBackground(sectionId, attempts + 1).then(resolve);
                        } else {
                            resolve(null);
                        }
                    };
                    testImg.src = candidate + (candidate.includes('?') ? '&' : '?') + 't=' + Date.now();
                } catch (_) {
                    resolve(null);
                }
            });
        }

        // Background lazy loader with small concurrency and per-section dedupe
        let _bgActiveLoads = 0;
        const _bgQueue = [];
        const _bgScheduled = new Set();
        const _bgActiveSet = new Set();
        function _processBgQueue() {
            while (_bgActiveLoads < 3 && _bgQueue.length > 0) {
                const next = _bgQueue.shift();
                if (!next || !next.id) continue;
                _bgActiveLoads++;
                _bgActiveSet.add(next.id);
                applyCardBackground(next.section).finally(() => {
                    _bgActiveLoads = Math.max(0, _bgActiveLoads - 1);
                    try { _bgActiveSet.delete(next.id); } catch(_) {}
                    try { _bgScheduled.delete(next.id); } catch(_) {}
                    _processBgQueue();
                });
            }
        }
        function scheduleCardBackground(section) {
            try {
                const sid = section && section.id ? String(section.id) : '';
                if (!sid) return;
                if (_bgScheduled.has(sid) || _bgActiveSet.has(sid)) return;
                _bgScheduled.add(sid);
                _bgQueue.push({ section, id: sid });
                _processBgQueue();
            } catch(_) {}
        }
        function isLowDataConnection() { return false; }
        function initBackgroundLazyLoad(sections) { (sections || []).forEach(s => scheduleCardBackground(s)); }
    }
    </script>
    <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Info bar styles */
        .info-bar {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            padding: 6px 10px;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            color: #333;
            font-size: 0.95rem;
            min-height: 28px;
            width: 100%;
            max-width: 100%;
        }
        .info-bar i { color: #4CAF50; }
        .info-bar .muted { color: #888; }
        .info-view-all { margin-left: 10px; font-size: 0.9rem; color: #667eea; text-decoration: none; white-space: nowrap; }
        .info-view-all:hover { text-decoration: underline; }
        /* Ensure header title/icon visibility */
        .header-title h1 { color: #fff; visibility: visible; }
        .logo-container .site-logo { display: inline-block; }
        .info-marquee { position: relative; overflow: hidden; flex: 1 1 auto; min-width: 0; width: 100%; }
        .header-title { max-width: 100%; }
        .logo-container { flex-wrap: wrap; }
        .info-marquee { position: relative; overflow: hidden; flex: 1; }
        .info-marquee-track {
            display: inline-block;
            white-space: nowrap;
            will-change: transform;
            /* Base speed is intentionally slow; JS further adjusts duration */
            animation: info-scroll 60s linear infinite;
        }
        .info-bar:hover .info-marquee-track { animation-play-state: paused; }
        .info-item { display: inline-flex; align-items: center; gap: 8px; padding: 0 24px; }
        .info-sep { opacity: 0.4; padding: 0 8px; }
        @keyframes info-scroll {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }

        .sections-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 20px 0;
        }
        
        .section-item {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #e9ecef;
            text-align: center;
        }
        
        .section-item i {
            font-size: 2rem;
            color: #4CAF50;
            margin-bottom: 10px;
        }
        
        .section-item h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        .section-item p {
            color: #666;
            font-size: 0.9rem;
        }
        
        /* Permission Management Styles */
        .permission-management {
            padding: 20px 0;
        }
        
        .user-selector {
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 1px solid #e9ecef;
        }
        
        .user-selector label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }
        
        .user-selector select {
            width: 100%;
            padding: 10px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            background: white;
        }
        
        .permission-form {
            background: white;
            padding: 25px;
            border-radius: 15px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .permission-form h4 {
            margin-bottom: 25px;
            color: #333;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .permission-section {
            margin-bottom: 30px;
        }
        
        .permission-section h5 {
            margin-bottom: 15px;
            color: #555;
            font-size: 1.1rem;
        }
        
        .section-permissions, .edit-permissions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        
        .permission-item {
            display: flex;
            align-items: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            transition: all 0.3s ease;
        }
        
        .permission-item:hover {
            background: #e9ecef;
        }
        
        .permission-item label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 500;
            color: #333;
            margin: 0;
        }
        
        .permission-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4CAF50;
        }
        
        .permission-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }
        
        .permission-actions .btn {
            padding: 12px 25px;
            font-size: 1rem;
        }
        
        /* Section Management Styles */
        .sections-management {
            padding: 20px 0;
        }
        
        .sections-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .section-item-admin {
            display: flex;
            align-items: center;
            padding: 20px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            cursor: move;
        }
        
        .section-item-admin:hover {
            border-color: #4CAF50;
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.2);
        }
        .section-drag-handle {
            margin-right: 15px;
            color: #999;
            font-size: 1.2rem;
            cursor: grab;
        }
        
        .section-drag-handle:active {
            cursor: grabbing;
        }
        
        .section-info {
            display: flex;
            align-items: center;
            flex: 1;
            gap: 15px;
        }
        
        .section-icon {
            font-size: 2rem;
            color: #4CAF50;
            width: 50px;
            text-align: center;
        }
        .section-img-icon {
            width: 36px;
            height: 36px;
            object-fit: contain;
        }
        
        .section-details h4 {
            margin: 0 0 5px 0;
            color: #333;
            font-size: 1.2rem;
        }
        
        .section-details p {
            margin: 0;
            color: #666;
            font-size: 0.9rem;
        }
        
        .section-controls {
            display: flex;
            align-items: center;
            gap: 20px;
        }
        
        .visibility-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .visibility-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4CAF50;
        }
        
        .toggle-label {
            font-weight: 500;
            color: #333;
        }
        
        .section-actions {
            display: flex;
            gap: 8px;
        }
        
        .btn-sm {
            padding: 6px 12px;
            font-size: 0.9rem;
        }
        
        .section-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #e9ecef;
        }
        
        .section-actions .btn {
            padding: 10px 20px;
        }
        
        /* Admin Quick Access Styles */
        .admin-quick-access {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 30px 0;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }
        
        .admin-quick-access h3 {
            margin: 0 0 20px 0;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .admin-quick-actions {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .admin-quick-actions .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Section Assignments Styles */
        .assignments-list {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .assignment-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 1px solid #e0e0e0;
        }
        
        .user-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .user-info h4 {
            margin: 0;
            color: #333;
        }
        
        .user-role {
            background: #667eea;
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        .section-assignments h5 {
            margin: 0 0 15px 0;
            color: #555;
            font-size: 1rem;
        }
        
        .section-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .section-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid #e0e0e0;
        }
        
        .section-checkbox:hover {
            background: #e9ecef;
            border-color: #667eea;
        }
        
        .section-checkbox input[type="checkbox"] {
            margin: 0;
            cursor: pointer;
        }
        
        .section-checkbox i {
            color: #667eea;
            width: 16px;
        }
        
        .section-checkbox span {
            font-size: 0.9rem;
            color: #333;
        }
        
        .assignment-actions {
            display: flex;
            gap: 10px;
        }
        
        .assignment-actions .btn {
            padding: 8px 16px;
            font-size: 0.9rem;
        }
        
        .admin-quick-actions .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .admin-quick-actions .btn-primary {
            background: #4CAF50;
            color: white;
        }
        
        .admin-quick-actions .btn-secondary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        .admin-quick-actions .btn-warning {
            background: #ff9800;
            color: white;
        }
        
        /* Admin Panel Modal Styles */
        .admin-modal .modal-content {
            max-width: 1000px !important;
            width: 95% !important;
            max-height: 90vh !important;
            margin: 2% auto !important;
            display: flex;
            flex-direction: column;
        }
        
        .admin-modal .modal-body {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        /* Make admin tabs horizontally scrollable to avoid truncation */
        .admin-tabs {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            gap: 10px;
            padding: 8px 4px 6px 4px;
        }
        .admin-tabs::-webkit-scrollbar { height: 6px; }
        .admin-tabs::-webkit-scrollbar-thumb { background: #d0d3d9; border-radius: 6px; }
        .admin-tab { flex: 0 0 auto; white-space: nowrap; }
        
        /* Add User Modal overlay and stacking */
        #addUserModal {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.45);
            z-index: 10002 !important;
        }
        #addUserModal .modal-content {
            position: relative;
            z-index: 10003 !important;
            max-width: 560px !important;
            width: 95% !important;
            margin: 6% auto !important;
        }

        /* Make add user modal body scrollable and actions sticky */
        #addUserModal .modal-body {
            max-height: 60vh;
            overflow-y: auto;
        }
        #addUserModal .form-actions {
            position: sticky;
            bottom: 0;
            background: #fff;
            padding-top: 10px;
            border-top: 1px solid #e9ecef;
        }
        /* Edit User Modal overlay and stacking */
        #editUserModal {
            position: fixed !important;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.45);
            z-index: 10004 !important;
        }
        #editUserModal .modal-content {
            position: relative;
            z-index: 10005 !important;
        }

        /* Make permission form save actions sticky to avoid needing zoom */
        .permission-actions {
            position: sticky;
            bottom: 0;
            background: #fff;
        }

        /* Shrink hub cards and grid for smaller viewports */
        .hub-grid {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 14px;
        }
        .hub-card {
            padding: 14px;
        }
        .hub-card .card-icon i {
            font-size: 28px;
        }
        .hub-card h3 {
            font-size: 1.1rem;
        }
        .hub-card p {
            font-size: 0.9rem;
        }

        /* Shrink section admin list visuals a bit */
        .section-item-admin {
            padding: 14px;
        }
        .section-icon { font-size: 1.5rem; }

        /* Compact admin mode */
        .compact-admin .admin-tabs { gap: 6px; }
        .compact-admin .admin-tab { padding: 6px 10px; font-size: 0.9rem; }
        .compact-admin .admin-section-header h3 { font-size: 1rem; }
        .compact-admin .admin-section-header .btn { padding: 6px 10px; font-size: 0.85rem; }
        .compact-admin .users-list .user-item { padding: 10px; }
        .compact-admin .permission-form { padding: 16px; }
        .compact-admin .export-card { padding: 12px; }
        
        .admin-modal .admin-content {
            max-height: 70vh;
            overflow-y: auto;
            padding: 20px 30px 80px 30px;
            position: relative;
        }
        
        .admin-modal .admin-tab-content {
            max-height: none;
            overflow: visible;
        }
        
        .admin-modal .permission-management {
            max-height: 60vh;
            overflow-y: auto;
        }
        
        /* Force scrolling to work */
        .admin-modal {
            overflow: hidden !important;
        }
        
        .admin-modal .modal-content {
            overflow: hidden !important;
        }
        
        .admin-modal .modal-body {
            overflow: hidden !important;
        }
        
        .admin-modal .admin-content {
            overflow-y: scroll !important;
            -webkit-overflow-scrolling: touch;
        }
        /* Improved Edit User Modal Styles */
        .edit-user-modal {
            max-width: 800px !important;
            width: 90% !important;
            max-height: 90vh !important;
            margin: 5% auto !important;
        }
        
        .edit-user-body {
            max-height: 70vh;
            overflow-y: auto;
            padding: 20px 30px;
        }
        
        .user-basic-info {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e9ecef;
        }
        
        .section-permissions-container {
            margin-top: 20px;
        }
        
        .section-permissions-container h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.2rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 10px;
        }
        
        .section-checkboxes {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            background: #f8f9fa;
        }
        .section-checkbox {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 6px;
            border: 1px solid #e9ecef;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .section-checkbox:hover {
            background: #e9ecef;
            border-color: #4CAF50;
        }
        
        .section-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4CAF50;
        }
        
        .section-checkbox span {
            font-weight: 500;
            color: #333;
        }
        
        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .edit-user-modal {
                width: 95% !important;
                margin: 2% auto !important;
            }
            
            .edit-user-body {
                max-height: 80vh;
                padding: 15px 20px;
            }
            
            .section-checkboxes {
                grid-template-columns: 1fr;
                max-height: 250px;
            }
        }
        
        /* Keep Save Order visible in Manage Sections */
        .sections-management { position: relative; }
        .sections-management .section-actions {
            position: sticky;
            bottom: 0;
            background: #fff;
            padding: 12px 10px;
            border-top: 1px solid #e9ecef;
            box-shadow: 0 -2px 8px rgba(0,0,0,0.05);
            z-index: 2;
        }
        .sections-management .sections-list { padding-bottom: 8px; }

        /* Quick Actions compact sizing */
        .quick-actions { margin: 2px 0; padding: 0; background: transparent; border: 0; box-shadow: none; }
        .quick-actions h3 { margin: 0 0 4px 0; font-size: 1rem; }
        .quick-actions .action-buttons { display: flex; flex-wrap: wrap; gap: 6px; align-items: center; margin: 0; }
        .quick-actions .action-btn { padding: 4px 8px; font-size: 0.85rem; line-height: 1.1; }
    </style>
    <script>
        (function(){
            window.openGithubPanel = function(){
                alert('GitHub integration has been removed. All data is now stored in Supabase database.');
            };
        })();
    </script>
    <script>
        (function(){
            try {
                // Live-sync hub counts when section pages change resources/config
                var bc = (typeof BroadcastChannel !== 'undefined') ? new BroadcastChannel('hub-sync') : null;
                if (bc) {
                    bc.onmessage = function(ev){
                        try {
                            var t = ev && ev.data && ev.data.type;
                            if (t === 'RESOURCE_CHANGE' || t === 'NAV_BACK' || t === 'SECTION_CUSTOMIZE') {
                                if (typeof updateMainHubSections === 'function') updateMainHubSections();
                                else if (typeof updateSectionStats === 'function') updateSectionStats();
                            }
                        } catch(_) {}
                    };
                }
                window.addEventListener('storage', function(ev){
                    try {
                        var k = ev && ev.key || '';
                        if (k === 'refreshHubNow' || k === 'hubLastChange' || (k && k.indexOf('section_config_') === 0)) {
                            console.log('Storage event triggered updateMainHubSections:', k);
                            if (typeof updateMainHubSections === 'function') updateMainHubSections();
                            else if (typeof updateSectionStats === 'function') updateSectionStats();
                        }
                    } catch(_) {}
                });
            } catch(_) {}
        })();
    </script>
    <script>
        (function(){
                window.ensureSectionConfigsFile = async function ensureSectionConfigsFile(){
                alert('GitHub integration has been removed. Section configs are now managed through Supabase database.');
                return false;
            };
        })();
    </script>
    <style>
        /* Ensure text remains visible; switch to white only when background image arrives */
        .hub-card.bg-ready h3,
        .hub-card.bg-ready p,
        .hub-card.bg-ready span,
        .hub-card.bg-ready i { color: #fff !important; }
    </style>
    <script>
        (function(){
            function isAdmin() {
                try {
                    var s = localStorage.getItem('hubSession');
                    if (!s) return false;
                    var u = JSON.parse(s);
                    var role = String(u.role || '').toLowerCase();
                    return role === 'admin' || !!(u.permissions && u.permissions.canManageUsers === true);
                } catch(_) { return false; }
            }
        })();
    </script>
    <script>
        // Initialize database (no default sections)
        (function(){
            // Initialize HubDatabase
            if (typeof HubDatabase !== 'undefined') {
                window.hubDatabase = new HubDatabase();
                window.hubDatabaseReady = false;
                
                // Wait for database to be ready
                const initDatabase = async () => {
                    if (window.hubDatabase && window.hubDatabase.supabase) {
                        window.hubDatabaseReady = true;
                        console.log('Database initialized');
                        try { document.dispatchEvent(new Event('hubdb-ready')); } catch(_) {}
                        try { updateBackgroundToggleButton(); } catch(_) {}
                    } else {
                        setTimeout(initDatabase, 100);
                    }
                };
                initDatabase();
            }
        })();
    </script>
    <script>
        (function(){
            if (window.supabaseClient) return;
            function ensureKeys(){
                try {
                    // No localStorage fallbacks; keys must be provided by CONFIG/meta/constants
                } catch(_) {}
            }
            function initClient(){
                ensureKeys();
                var SUPABASE_URL = window.SUPABASE_URL || 'https://YOUR-PROJECT-ref.supabase.co';
                var SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR-ANON-KEY';
                try {
                    if (window.supabase && !window.supabaseClient) {
                        window.supabaseClient = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, { auth: { persistSession: true, autoRefreshToken: true, detectSessionInUrl: true } });
                    }
                } catch(_) {}
            }
            function loadFallbacksIfNeeded(){
                if (window.supabase) return initClient();
                var tried = 0; var cdns = ['https://unpkg.com/@supabase/supabase-js@2/dist/umd/supabase.js'];
                function next(){
                    if (window.supabase) return initClient();
                    if (tried < cdns.length){
                        var s = document.createElement('script');
                        s.src = cdns[tried++]; s.async = true; s.onload = initClient; s.onerror = next; document.head.appendChild(s);
                    } else {
                        var m = document.createElement('script'); m.type = 'module';
                        m.textContent = "import{createClient}from 'https://esm.sh/@supabase/supabase-js@2'; window.supabase={createClient}; window.dispatchEvent(new Event('supabase-ready'));";
                        document.head.appendChild(m);
                        window.addEventListener('supabase-ready', initClient, { once: true });
                    }
                }
                next();
            }
            // Use fallback loader only if client isn't already initialized correctly
            if (!(window.supabase && window.supabase.createClient) || !window.SUPABASE_CLIENT_READY) { loadFallbacksIfNeeded(); } else { initClient(); }

            // Clean stale local data artifacts to ensure Supabase-only view
            (function clearLocalArtifacts(){
                try {
                    var keys = [
                        'informationHub','sectionOrder','hubUsers','hubActivities','githubToken',
                        'refreshHubNow','hubLastChange','dbMigrationDone'
                    ];
                    keys.forEach(function(k){ try { localStorage.removeItem(k); } catch(_){} });
                    // Remove per-section caches
                    try {
                        for (var i=0;i<localStorage.length;i++){
                            var k = localStorage.key(i);
                            if (k && (k.indexOf('section_')===0 || k.indexOf('section_config_')===0)){
                                try { localStorage.removeItem(k); } catch(_){}
                            }
                        }
                    } catch(_){}
                    // Best-effort delete old IndexedDB
                    try { window.indexedDB && window.indexedDB.deleteDatabase && window.indexedDB.deleteDatabase('InformationHubDB'); } catch(_){}
                } catch(_){}
            })();

            // Helper to seed one example resource if database is empty (run manually by admin)
            window.seedExampleIfEmpty = async function(){
                try {
                    if (!window.supabaseClient) return alert('Supabase not ready');
                    // Check if any resources exist in standard hub sections
                    var sections = ['costing','supply-planning','operations','quality','hr','it','sales','compliance'];
                    var total = 0;
                    for (var i=0;i<sections.length;i++){
                        var { count, error } = await window.supabaseClient
                            .from('resources')
                            .select('*', { count: 'exact', head: true })
                            .eq('section_id', sections[i]);
                        if (error) { console.warn(error); continue; }
                        total += (count||0);
                        if (total>0) break;
                    }
                    if (total>0) return alert('Database already has resources. Nothing to seed.');
                    var sample = {
                        section_id: 'costing',
                        type: 'playbooks',
                        title: 'Getting Started',
                        description: 'How to use the hub and add your first items',
                        url: 'https://example.com/getting-started',
                        tags: ['onboarding','guide']
                    };
                    var { error: insErr } = await window.supabaseClient.from('resources').insert(sample).select().single();
                    if (insErr) return alert('Seed failed: ' + insErr.message + '\nTip: sign in as admin or grant edit rights.');
                    alert('Seeded one example resource in "costing".');
                } catch(e){ alert('Seed failed: ' + (e && e.message ? e.message : e)); }
            };

                window.fetchSections = async function(){
                    var q = window.supabaseClient
                        .from('sections')
                        .select('section_id,name,icon,color,config')
                        .order('name', { ascending: true });
                    var res = await q;
                    if (res.error) throw res.error;
                    return res.data || [];
                };

                window.fetchResourcesBySection = async function(sectionId, type){
                    var q = window.supabaseClient
                        .from('resources')
                        .select('*')
                        .eq('section_id', sectionId);
                    if (type) q = q.eq('type', type);
                    q = q.order('created_at', { ascending: false });
                    var res = await q;
                    if (res.error) throw res.error;
                    return res.data || [];
                };

                window.addResource = async function(rec){
                    var res = await window.supabaseClient
                        .from('resources')
                        .insert(rec)
                        .select()
                        .single();
                    if (res.error) throw res.error;
                    return res.data;
                };

                window.recordView = async function(resourceId){
                    try {
                        var ures = await window.supabaseClient.auth.getUser();
                        var userId = (ures && ures.data && ures.data.user && ures.data.user.id) ? ures.data.user.id : null;
                        var r = await window.supabaseClient.rpc('increment_view', { p_user_id: userId, p_resource_id: resourceId });
                        if (r && r.error) console.warn('view rpc failed', r.error);
                    } catch(e) { console.warn('recordView failed', e); }
                };

                // Quick password change helper (opens prompt)
                window.changePasswordQuick = async function(){
                    try {
                        var p1 = prompt('Enter new password (min 6 chars):'); if (!p1 || p1.length < 6) return alert('Cancelled');
                        var p2 = prompt('Confirm new password:'); if (p1 !== p2) return alert('Mismatch');
                        var r = await window.supabaseClient.auth.updateUser({ password: p1 });
                        if (r && r.error) return alert('Failed: ' + r.error.message);
                        alert('Password updated');
                    } catch(e){ alert('Failed: ' + (e && e.message ? e.message : e)); }
                };

                // Realtime: refresh hub stats on any resource or section change
                try {
                    if (!window.supabaseHubChannel) {
                        var ch = window.supabaseClient
                            .channel('hub-realtime')
                            .on('postgres_changes', { event: '*', schema: 'public', table: 'resources' }, function(){ try { if (typeof updateSectionStats === 'function') updateSectionStats(); } catch(_) {} })
                            .on('postgres_changes', { event: '*', schema: 'public', table: 'sections' }, function(){ try { if (typeof updateSectionStats === 'function') updateSectionStats(); } catch(_) {} })
                            .subscribe();
                        window.supabaseHubChannel = ch;
                        try { window.addEventListener('beforeunload', function(){ try { window.supabaseClient.removeChannel(ch); } catch(_) {} }, { once: true }); } catch(_) {}
                    }
                } catch(_) {}
        })();
    </script>
    <script>
        // Ensure the loader function is exposed globally even if scripts load out of order
        (function ensureLoadSectionsFromSupabaseBinding(){
            try {
                if (typeof window.loadSectionsFromSupabase === 'function') return;
                if (typeof loadSectionsFromSupabase === 'function') {
                    window.loadSectionsFromSupabase = loadSectionsFromSupabase;
                    return;
                }
                var tries = 0;
                var iv = setInterval(function(){
                    try {
                        if (typeof loadSectionsFromSupabase === 'function') {
                            window.loadSectionsFromSupabase = loadSectionsFromSupabase;
                            clearInterval(iv);
                        }
                        if (++tries > 200) clearInterval(iv);
                    } catch(_) { if (++tries > 200) clearInterval(iv); }
                }, 50);
            } catch(_) {}
        })();
    </script>
</body>
</html>